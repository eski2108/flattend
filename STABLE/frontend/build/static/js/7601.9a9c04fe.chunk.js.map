{"version":3,"file":"static/js/7601.9a9c04fe.chunk.js","mappings":"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","sources":["../node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot/src/slot.tsx","../node_modules/@radix-ui/react-collection/src/ordered-dictionary.ts","../node_modules/@radix-ui/react-direction/src/direction.tsx","../node_modules/@radix-ui/react-roving-focus/src/roving-focus-group.tsx","../node_modules/@radix-ui/react-collection/src/collection-legacy.tsx","../node_modules/@radix-ui/react-tabs/src/tabs.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlot(ownerName: string) {\n  const SlotClone = createSlotClone(ownerName);\n  const Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n\n    if (slottable) {\n      // the new element to render is the one passed as a child of `Slottable`\n      const newElement = slottable.props.children;\n\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          // because the new element will be the one rendered, we are only interested\n          // in grabbing its children (`newElement.props.children`)\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement)\n            ? (newElement.props as { children: React.ReactNode }).children\n            : null;\n        } else {\n          return child;\n        }\n      });\n\n      return (\n        <SlotClone {...slotProps} ref={forwardedRef}>\n          {React.isValidElement(newElement)\n            ? React.cloneElement(newElement, undefined, newChildren)\n            : null}\n        </SlotClone>\n      );\n    }\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  });\n\n  Slot.displayName = `${ownerName}.Slot`;\n  return Slot;\n}\n\nconst Slot = createSlot('Slot');\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ function createSlotClone(ownerName: string) {\n  const SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props = mergeProps(slotProps, children.props as AnyProps);\n      // do not pass ref to React.Fragment for React 19 compatibility\n      if (children.type !== React.Fragment) {\n        props.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props);\n    }\n\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLOTTABLE_IDENTIFIER = Symbol('radix.slottable');\n\ninterface SlottableProps {\n  children: React.ReactNode;\n}\n\ninterface SlottableComponent extends React.FC<SlottableProps> {\n  __radixId: symbol;\n}\n\n/* @__NO_SIDE_EFFECTS__ */ export function createSlottable(ownerName: string) {\n  const Slottable: SlottableComponent = ({ children }) => {\n    return <>{children}</>;\n  };\n  Slottable.displayName = `${ownerName}.Slottable`;\n  Slottable.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable;\n}\n\nconst Slottable = createSlottable('Slottable');\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<SlottableProps, typeof Slottable> {\n  return (\n    React.isValidElement(child) &&\n    typeof child.type === 'function' &&\n    '__radixId' in child.type &&\n    child.type.__radixId === SLOTTABLE_IDENTIFIER\n  );\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Slot as Root,\n};\nexport type { SlotProps };\n","// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n","import * as React from 'react';\n\ntype Direction = 'ltr' | 'rtl';\nconst DirectionContext = React.createContext<Direction | undefined>(undefined);\n\n/* -------------------------------------------------------------------------------------------------\n * Direction\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DirectionProviderProps {\n  children?: React.ReactNode;\n  dir: Direction;\n}\nconst DirectionProvider: React.FC<DirectionProviderProps> = (props) => {\n  const { dir, children } = props;\n  return <DirectionContext.Provider value={dir}>{children}</DirectionContext.Provider>;\n};\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction useDirection(localDir?: Direction) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || 'ltr';\n}\n\nconst Provider = DirectionProvider;\n\nexport {\n  useDirection,\n  //\n  Provider,\n  //\n  DirectionProvider,\n};\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends Omit<PrimitiveSpanProps, 'children'> {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { hasTabStop: boolean; isCurrentTabStop: boolean }) => React.ReactNode);\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        >\n          {typeof children === 'function'\n            ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null })\n            : children}\n        </Primitive.span>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useId } from '@radix-ui/react-id';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Tabs\n * -----------------------------------------------------------------------------------------------*/\n\nconst TABS_NAME = 'Tabs';\n\ntype ScopedProps<P> = P & { __scopeTabs?: Scope };\nconst [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [\n  createRovingFocusGroupScope,\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype TabsContextValue = {\n  baseId: string;\n  value: string;\n  onValueChange: (value: string) => void;\n  orientation?: TabsProps['orientation'];\n  dir?: TabsProps['dir'];\n  activationMode?: TabsProps['activationMode'];\n};\n\nconst [TabsProvider, useTabsContext] = createTabsContext<TabsContextValue>(TABS_NAME);\n\ntype TabsElement = React.ComponentRef<typeof Primitive.div>;\ntype RovingFocusGroupProps = React.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface TabsProps extends PrimitiveDivProps {\n  /** The value for the selected tab, if controlled */\n  value?: string;\n  /** The value of the tab to select by default, if uncontrolled */\n  defaultValue?: string;\n  /** A function called when a new tab is selected */\n  onValueChange?: (value: string) => void;\n  /**\n   * The orientation the tabs are layed out.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   * @defaultValue horizontal\n   */\n  orientation?: RovingFocusGroupProps['orientation'];\n  /**\n   * The direction of navigation between toolbar items.\n   */\n  dir?: RovingFocusGroupProps['dir'];\n  /**\n   * Whether a tab is activated automatically or manually.\n   * @defaultValue automatic\n   * */\n  activationMode?: 'automatic' | 'manual';\n}\n\nconst Tabs = React.forwardRef<TabsElement, TabsProps>(\n  (props: ScopedProps<TabsProps>, forwardedRef) => {\n    const {\n      __scopeTabs,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      orientation = 'horizontal',\n      dir,\n      activationMode = 'automatic',\n      ...tabsProps\n    } = props;\n    const direction = useDirection(dir);\n    const [value, setValue] = useControllableState({\n      prop: valueProp,\n      onChange: onValueChange,\n      defaultProp: defaultValue ?? '',\n      caller: TABS_NAME,\n    });\n\n    return (\n      <TabsProvider\n        scope={__scopeTabs}\n        baseId={useId()}\n        value={value}\n        onValueChange={setValue}\n        orientation={orientation}\n        dir={direction}\n        activationMode={activationMode}\n      >\n        <Primitive.div\n          dir={direction}\n          data-orientation={orientation}\n          {...tabsProps}\n          ref={forwardedRef}\n        />\n      </TabsProvider>\n    );\n  }\n);\n\nTabs.displayName = TABS_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsList\n * -----------------------------------------------------------------------------------------------*/\n\nconst TAB_LIST_NAME = 'TabsList';\n\ntype TabsListElement = React.ComponentRef<typeof Primitive.div>;\ninterface TabsListProps extends PrimitiveDivProps {\n  loop?: RovingFocusGroupProps['loop'];\n}\n\nconst TabsList = React.forwardRef<TabsListElement, TabsListProps>(\n  (props: ScopedProps<TabsListProps>, forwardedRef) => {\n    const { __scopeTabs, loop = true, ...listProps } = props;\n    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n    return (\n      <RovingFocusGroup.Root\n        asChild\n        {...rovingFocusGroupScope}\n        orientation={context.orientation}\n        dir={context.dir}\n        loop={loop}\n      >\n        <Primitive.div\n          role=\"tablist\"\n          aria-orientation={context.orientation}\n          {...listProps}\n          ref={forwardedRef}\n        />\n      </RovingFocusGroup.Root>\n    );\n  }\n);\n\nTabsList.displayName = TAB_LIST_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TabsTrigger';\n\ntype TabsTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface TabsTriggerProps extends PrimitiveButtonProps {\n  value: string;\n}\n\nconst TabsTrigger = React.forwardRef<TabsTriggerElement, TabsTriggerProps>(\n  (props: ScopedProps<TabsTriggerProps>, forwardedRef) => {\n    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;\n    const context = useTabsContext(TRIGGER_NAME, __scopeTabs);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n    const triggerId = makeTriggerId(context.baseId, value);\n    const contentId = makeContentId(context.baseId, value);\n    const isSelected = value === context.value;\n    return (\n      <RovingFocusGroup.Item\n        asChild\n        {...rovingFocusGroupScope}\n        focusable={!disabled}\n        active={isSelected}\n      >\n        <Primitive.button\n          type=\"button\"\n          role=\"tab\"\n          aria-selected={isSelected}\n          aria-controls={contentId}\n          data-state={isSelected ? 'active' : 'inactive'}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          id={triggerId}\n          {...triggerProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click)\n            if (!disabled && event.button === 0 && event.ctrlKey === false) {\n              context.onValueChange(value);\n            } else {\n              // prevent focus to avoid accidental activation\n              event.preventDefault();\n            }\n          })}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if ([' ', 'Enter'].includes(event.key)) context.onValueChange(value);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => {\n            // handle \"automatic\" activation if necessary\n            // ie. activate tab following focus\n            const isAutomaticActivation = context.activationMode !== 'manual';\n            if (!isSelected && !disabled && isAutomaticActivation) {\n              context.onValueChange(value);\n            }\n          })}\n        />\n      </RovingFocusGroup.Item>\n    );\n  }\n);\n\nTabsTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TabsContent';\n\ntype TabsContentElement = React.ComponentRef<typeof Primitive.div>;\ninterface TabsContentProps extends PrimitiveDivProps {\n  value: string;\n\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TabsContent = React.forwardRef<TabsContentElement, TabsContentProps>(\n  (props: ScopedProps<TabsContentProps>, forwardedRef) => {\n    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;\n    const context = useTabsContext(CONTENT_NAME, __scopeTabs);\n    const triggerId = makeTriggerId(context.baseId, value);\n    const contentId = makeContentId(context.baseId, value);\n    const isSelected = value === context.value;\n    const isMountAnimationPreventedRef = React.useRef(isSelected);\n\n    React.useEffect(() => {\n      const rAF = requestAnimationFrame(() => (isMountAnimationPreventedRef.current = false));\n      return () => cancelAnimationFrame(rAF);\n    }, []);\n\n    return (\n      <Presence present={forceMount || isSelected}>\n        {({ present }) => (\n          <Primitive.div\n            data-state={isSelected ? 'active' : 'inactive'}\n            data-orientation={context.orientation}\n            role=\"tabpanel\"\n            aria-labelledby={triggerId}\n            hidden={!present}\n            id={contentId}\n            tabIndex={0}\n            {...contentProps}\n            ref={forwardedRef}\n            style={{\n              ...props.style,\n              animationDuration: isMountAnimationPreventedRef.current ? '0s' : undefined,\n            }}\n          >\n            {present && children}\n          </Primitive.div>\n        )}\n      </Presence>\n    );\n  }\n);\n\nTabsContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction makeTriggerId(baseId: string, value: string) {\n  return `${baseId}-trigger-${value}`;\n}\n\nfunction makeContentId(baseId: string, value: string) {\n  return `${baseId}-content-${value}`;\n}\n\nconst Root = Tabs;\nconst List = TabsList;\nconst Trigger = TabsTrigger;\nconst Content = TabsContent;\n\nexport {\n  createTabsScope,\n  //\n  Tabs,\n  TabsList,\n  TabsTrigger,\n  TabsContent,\n  //\n  Root,\n  List,\n  Trigger,\n  Content,\n};\nexport type { TabsProps, TabsListProps, TabsTriggerProps, TabsContentProps };\n"],"names":["createSlot","ownerName","SlotClone","createSlotClone","Slot2","React","props","forwardedRef","children","slotProps","_objectWithoutProperties","_excluded","childrenArray","toArray","slottable","find","isSlottable","newElement","newChildren","map","child","count","only","jsx","_objectSpread","ref","displayName","concat","_excluded2","childrenRef","element","_Object$getOwnPropert","_Object$getOwnPropert2","getter","Object","getOwnPropertyDescriptor","get","mayWarn","isReactWarning","getElementRef","props2","childProps","overrideProps","propName","slotPropValue","childPropValue","test","result","arguments","filter","Boolean","join","mergeProps","type","composeRefs","SLOTTABLE_IDENTIFIER","Symbol","__radixId","__instanciated","WeakMap","_keys","Map","at","array","index","Array","prototype","call","actualIndex","length","relativeIndex","toSafeInteger","toSafeIndex","number","Math","trunc","DirectionContext","useDirection","localDir","globalDir","ENTRY_FOCUS","EVENT_OPTIONS","bubbles","cancelable","GROUP_NAME","Collection","useCollection","createCollectionScope","name","PROVIDER_NAME","createCollectionContext","createContextScope","CollectionProviderImpl","useCollectionContext","collectionRef","current","itemMap","CollectionProvider","scope","COLLECTION_SLOT_NAME","CollectionSlotImpl","CollectionSlot","context","composedRefs","useComposedRefs","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlotImpl","CollectionItemSlot","itemData","set","delete","Provider","Slot","ItemSlot","collectionNode","orderedNodes","from","querySelectorAll","values","sort","a","b","indexOf","createCollection","createRovingFocusGroupContext","createRovingFocusGroupScope","RovingFocusProvider","useRovingFocusContext","RovingFocusGroup","__scopeRovingFocusGroup","RovingFocusGroupImpl","orientation","loop","dir","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","preventScrollOnEntryFocus","groupProps","direction","setCurrentTabStopId","useControllableState","prop","defaultProp","onChange","caller","isTabbingBackOut","setIsTabbingBackOut","handleEntryFocus","useCallbackRef","getItems","isClickFocusRef","focusableItemsCount","setFocusableItemsCount","node","addEventListener","removeEventListener","onItemFocus","tabStopId","onItemShiftTab","onFocusableItemAdd","prevCount","onFocusableItemRemove","Primitive","div","tabIndex","style","outline","onMouseDown","composeEventHandlers","onFocus","event","isKeyboardFocus","target","currentTarget","entryFocusEvent","CustomEvent","dispatchEvent","defaultPrevented","items","item","focusable","focusFirst","active","id","onBlur","ITEM_NAME","RovingFocusGroupItem","itemProps","autoId","useId","isCurrentTabStop","span","preventDefault","onKeyDown","key","shiftKey","focusIntent","getDirectionAwareKey","includes","MAP_KEY_TO_FOCUS_INTENT","getFocusIntent","metaKey","ctrlKey","altKey","candidateNodes","reverse","currentIndex","startIndex","_","slice","setTimeout","hasTabStop","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","candidates","preventScroll","undefined","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","Root","Item","TABS_NAME","createTabsContext","createTabsScope","useRovingFocusGroupScope","TabsProvider","useTabsContext","Tabs","__scopeTabs","value","valueProp","onValueChange","defaultValue","activationMode","tabsProps","setValue","baseId","TAB_LIST_NAME","TabsList","listProps","rovingFocusGroupScope","asChild","role","TRIGGER_NAME","TabsTrigger","disabled","triggerProps","_excluded3","triggerId","makeTriggerId","contentId","makeContentId","isSelected","button","isAutomaticActivation","CONTENT_NAME","TabsContent","forceMount","contentProps","_excluded4","isMountAnimationPreventedRef","rAF","requestAnimationFrame","cancelAnimationFrame","Presence","present","_ref","hidden","animationDuration","Root2","List","Trigger","Content"],"sourceRoot":""}