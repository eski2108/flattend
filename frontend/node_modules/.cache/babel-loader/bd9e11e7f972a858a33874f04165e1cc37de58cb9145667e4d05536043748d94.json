{"ast":null,"code":"import axios from'axios';const API=process.env.REACT_APP_BACKEND_URL;// Cache for prices to avoid excessive API calls\nlet priceCache={};let lastFetchTime={};const CACHE_DURATION=30000;// 30 seconds\n// Currency exchange rates (relative to GBP)\n// Updated periodically from live forex rates\nconst EXCHANGE_RATES={'GBP':1.0,// Base currency\n'USD':1.27,// US Dollar\n'EUR':1.17,// Euro (Spain, Germany, France, Italy, etc.)\n'NGN':1960,// Nigerian Naira\n'INR':105,// Indian Rupee\n'AUD':1.95,// Australian Dollar\n'CAD':1.72,// Canadian Dollar\n'ZAR':23.5,// South African Rand\n'KES':165,// Kenyan Shilling\n'GHS':16.2,// Ghanaian Cedi\n'JPY':190,// Japanese Yen\n'CNY':9.2,// Chinese Yuan\n'BRL':6.3,// Brazilian Real\n'MXN':21.8,// Mexican Peso\n'CHF':1.12,// Swiss Franc\n'SEK':13.5,// Swedish Krona\n'NOK':13.8,// Norwegian Krone\n'DKK':8.7,// Danish Krone\n'PLN':5.1,// Polish Zloty\n'AED':4.67,// UAE Dirham\n'SAR':4.76// Saudi Riyal\n};/**\n * Fetch live price for a cryptocurrency\n * @param {string} coinSymbol - BTC, ETH, USDT, etc.\n * @returns {Promise<number>} - Price in GBP\n */export const fetchLivePrice=async coinSymbol=>{const now=Date.now();// Return cached price if recent\nif(priceCache[coinSymbol]&&lastFetchTime[coinSymbol]&&now-lastFetchTime[coinSymbol]<CACHE_DURATION){return priceCache[coinSymbol];}try{const response=await axios.get(\"\".concat(API,\"/api/prices/live\"));if(response.data.success&&response.data.prices){const coinData=response.data.prices[coinSymbol];if(coinData&&coinData.price_gbp){priceCache[coinSymbol]=coinData.price_gbp;lastFetchTime[coinSymbol]=now;return coinData.price_gbp;}}}catch(error){console.error(\"Error fetching price for \".concat(coinSymbol,\":\"),error);}return null;};/**\n * Convert fiat amount to crypto amount\n * @param {number} fiatAmount - Amount in fiat currency\n * @param {string} coinSymbol - Cryptocurrency symbol\n * @param {string} fiatCurrency - GBP, USD, NGN\n * @param {number} fee - Fee percentage (e.g., 2.5 for 2.5%)\n * @returns {Promise<Object>} - { cryptoAmount, pricePerUnit, totalWithFee, feeAmount }\n */export const convertFiatToCrypto=async function(fiatAmount,coinSymbol){let fiatCurrency=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'GBP';let fee=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;const amount=parseFloat(fiatAmount);if(isNaN(amount)||amount<=0){return{cryptoAmount:0,pricePerUnit:0,totalWithFee:0,feeAmount:0};}const priceInGBP=await fetchLivePrice(coinSymbol);if(!priceInGBP){return{cryptoAmount:0,pricePerUnit:0,totalWithFee:0,feeAmount:0,error:'Price unavailable'};}// Convert to target currency using exchange rates\nconst exchangeRate=EXCHANGE_RATES[fiatCurrency]||1.0;const priceInTargetCurrency=priceInGBP*exchangeRate;// Calculate fee\nconst feeAmount=amount*fee/100;const netAmount=amount-feeAmount;// Calculate crypto amount\nconst cryptoAmount=netAmount/priceInTargetCurrency;return{cryptoAmount:parseFloat(cryptoAmount.toFixed(8)),pricePerUnit:priceInTargetCurrency,totalWithFee:amount,feeAmount:parseFloat(feeAmount.toFixed(2)),netAmount:parseFloat(netAmount.toFixed(2))};};/**\n * Convert crypto amount to fiat amount\n * @param {number} cryptoAmount - Amount in cryptocurrency\n * @param {string} coinSymbol - Cryptocurrency symbol\n * @param {string} fiatCurrency - GBP, USD, NGN\n * @param {number} fee - Fee percentage (e.g., 2.5 for 2.5%)\n * @returns {Promise<Object>} - { fiatAmount, pricePerUnit, totalWithFee, feeAmount }\n */export const convertCryptoToFiat=async function(cryptoAmount,coinSymbol){let fiatCurrency=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'GBP';let fee=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;const amount=parseFloat(cryptoAmount);if(isNaN(amount)||amount<=0){return{fiatAmount:0,pricePerUnit:0,totalWithFee:0,feeAmount:0};}const priceInGBP=await fetchLivePrice(coinSymbol);if(!priceInGBP){return{fiatAmount:0,pricePerUnit:0,totalWithFee:0,feeAmount:0,error:'Price unavailable'};}// Convert to target currency using exchange rates\nconst exchangeRate=EXCHANGE_RATES[fiatCurrency]||1.0;const priceInTargetCurrency=priceInGBP*exchangeRate;// Calculate fiat value\nconst fiatValue=amount*priceInTargetCurrency;// Calculate fee\nconst feeAmount=fiatValue*fee/100;const totalWithFee=fiatValue+feeAmount;return{fiatAmount:parseFloat(fiatValue.toFixed(2)),pricePerUnit:priceInTargetCurrency,totalWithFee:parseFloat(totalWithFee.toFixed(2)),feeAmount:parseFloat(feeAmount.toFixed(2)),netAmount:parseFloat(fiatValue.toFixed(2))};};/**\n * Get currency symbol\n * @param {string} currency - Currency code\n * @returns {string} - Currency symbol\n */export const getCurrencySymbol=currency=>{const symbols={'GBP':'£','USD':'$','EUR':'€','NGN':'₦','INR':'₹','AUD':'A$','CAD':'C$','ZAR':'R','KES':'KSh','GHS':'₵','JPY':'¥','CNY':'¥','BRL':'R$','MXN':'$','CHF':'Fr','SEK':'kr','NOK':'kr','DKK':'kr','PLN':'zł','AED':'د.إ','SAR':'﷼'};return symbols[currency]||currency;};/**\n * Format fiat amount with currency symbol\n * @param {number} amount - Fiat amount\n * @param {string} currency - Currency code\n * @returns {string} - Formatted string\n */export const formatFiatAmount=function(amount){let currency=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'GBP';const symbol=getCurrencySymbol(currency);return\"\".concat(symbol).concat(parseFloat(amount).toFixed(2));};/**\n * Format crypto amount\n * @param {number} amount - Crypto amount\n * @param {string} symbol - Crypto symbol\n * @returns {string} - Formatted string\n */export const formatCryptoAmount=function(amount){let symbol=arguments.length>1&&arguments[1]!==undefined?arguments[1]:'';return\"\".concat(parseFloat(amount).toFixed(8),\" \").concat(symbol).trim();};/**\n * Validate balance\n * @param {number} amount - Amount to check\n * @param {number} available - Available balance\n * @param {boolean} isCrypto - Whether amount is in crypto\n * @returns {Object} - { valid, message }\n */export const validateBalance=function(amount,available){let isCrypto=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;const parsedAmount=parseFloat(amount);const parsedAvailable=parseFloat(available);if(isNaN(parsedAmount)||parsedAmount<=0){return{valid:false,message:'Please enter a valid amount'};}if(parsedAmount>parsedAvailable){return{valid:false,message:\"Insufficient balance. Available: \".concat(isCrypto?parsedAvailable.toFixed(8):parsedAvailable.toFixed(2))};}return{valid:true,message:''};};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}