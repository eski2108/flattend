{"ast":null,"code":"/*!\n * @license\n * TradingView Lightweight Charts v4.0.0\n * Copyright (c) 2023 TradingView, Inc.\n * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0\n */\nimport { size as t, bindCanvasElementBitmapSizeTo as i, equalSizes as n, tryCreateCanvasRenderingTarget2D as s } from \"fancy-canvas\";\nvar e, r;\nfunction h(t, i) {\n  const n = {\n    0: [],\n    1: [t.lineWidth, t.lineWidth],\n    2: [2 * t.lineWidth, 2 * t.lineWidth],\n    3: [6 * t.lineWidth, 6 * t.lineWidth],\n    4: [t.lineWidth, 4 * t.lineWidth]\n  }[i];\n  t.setLineDash(n);\n}\nfunction l(t, i, n, s) {\n  t.beginPath();\n  const e = t.lineWidth % 2 ? .5 : 0;\n  t.moveTo(n, i + e), t.lineTo(s, i + e), t.stroke();\n}\nfunction a(t, i) {\n  if (!t) throw new Error(\"Assertion failed\" + (i ? \": \" + i : \"\"));\n}\nfunction o(t) {\n  if (void 0 === t) throw new Error(\"Value is undefined\");\n  return t;\n}\nfunction _(t) {\n  if (null === t) throw new Error(\"Value is null\");\n  return t;\n}\nfunction u(t) {\n  return _(o(t));\n}\n!function (t) {\n  t[t.Simple = 0] = \"Simple\", t[t.WithSteps = 1] = \"WithSteps\", t[t.Curved = 2] = \"Curved\";\n}(e || (e = {})), function (t) {\n  t[t.Solid = 0] = \"Solid\", t[t.Dotted = 1] = \"Dotted\", t[t.Dashed = 2] = \"Dashed\", t[t.LargeDashed = 3] = \"LargeDashed\", t[t.SparseDotted = 4] = \"SparseDotted\";\n}(r || (r = {}));\nconst c = {\n  khaki: \"#f0e68c\",\n  azure: \"#f0ffff\",\n  aliceblue: \"#f0f8ff\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gainsboro: \"#dcdcdc\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  honeydew: \"#f0fff0\",\n  floralwhite: \"#fffaf0\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lemonchiffon: \"#fffacd\",\n  hotpink: \"#ff69b4\",\n  lightyellow: \"#ffffe0\",\n  greenyellow: \"#adff2f\",\n  lightgoldenrodyellow: \"#fafad2\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  lightcyan: \"#e0ffff\",\n  magenta: \"#f0f\",\n  maroon: \"#800000\",\n  olive: \"#808000\",\n  orange: \"#ffa500\",\n  oldlace: \"#fdf5e6\",\n  mediumblue: \"#0000cd\",\n  transparent: \"#0000\",\n  lime: \"#0f0\",\n  lightpink: \"#ffb6c1\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  midnightblue: \"#191970\",\n  orchid: \"#da70d6\",\n  mediumorchid: \"#ba55d3\",\n  mediumturquoise: \"#48d1cc\",\n  orangered: \"#ff4500\",\n  royalblue: \"#4169e1\",\n  powderblue: \"#b0e0e6\",\n  red: \"#f00\",\n  coral: \"#ff7f50\",\n  turquoise: \"#40e0d0\",\n  white: \"#fff\",\n  whitesmoke: \"#f5f5f5\",\n  wheat: \"#f5deb3\",\n  teal: \"#008080\",\n  steelblue: \"#4682b4\",\n  bisque: \"#ffe4c4\",\n  aquamarine: \"#7fffd4\",\n  aqua: \"#0ff\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  springgreen: \"#00ff7f\",\n  antiquewhite: \"#faebd7\",\n  burlywood: \"#deb887\",\n  brown: \"#a52a2a\",\n  beige: \"#f5f5dc\",\n  chocolate: \"#d2691e\",\n  chartreuse: \"#7fff00\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cadetblue: \"#5f9ea0\",\n  tomato: \"#ff6347\",\n  fuchsia: \"#f0f\",\n  blue: \"#00f\",\n  salmon: \"#fa8072\",\n  blanchedalmond: \"#ffebcd\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  thistle: \"#d8bfd8\",\n  tan: \"#d2b48c\",\n  cyan: \"#0ff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  blueviolet: \"#8a2be2\",\n  black: \"#000\",\n  darkmagenta: \"#8b008b\",\n  darkslateblue: \"#483d8b\",\n  darkkhaki: \"#bdb76b\",\n  darkorchid: \"#9932cc\",\n  darkorange: \"#ff8c00\",\n  darkgreen: \"#006400\",\n  darkred: \"#8b0000\",\n  dodgerblue: \"#1e90ff\",\n  darkslategray: \"#2f4f4f\",\n  dimgray: \"#696969\",\n  deepskyblue: \"#00bfff\",\n  firebrick: \"#b22222\",\n  forestgreen: \"#228b22\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  lavenderblush: \"#fff0f5\",\n  feldspar: \"#d19275\",\n  indianred: \"#cd5c5c\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#789\",\n  lightslateblue: \"#8470ff\",\n  snow: \"#fffafa\",\n  lightseagreen: \"#20b2aa\",\n  lightsalmon: \"#ffa07a\",\n  darksalmon: \"#e9967a\",\n  darkviolet: \"#9400d3\",\n  mediumpurple: \"#9370d8\",\n  mediumaquamarine: \"#66cdaa\",\n  skyblue: \"#87ceeb\",\n  lavender: \"#e6e6fa\",\n  lightsteelblue: \"#b0c4de\",\n  mediumvioletred: \"#c71585\",\n  mintcream: \"#f5fffa\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  olivedrab: \"#6b8e23\",\n  palevioletred: \"#d87093\",\n  violetred: \"#d02090\",\n  yellow: \"#ff0\",\n  yellowgreen: \"#9acd32\",\n  lawngreen: \"#7cfc00\",\n  pink: \"#ffc0cb\",\n  paleturquoise: \"#afeeee\",\n  palegoldenrod: \"#eee8aa\",\n  darkolivegreen: \"#556b2f\",\n  darkseagreen: \"#8fbc8f\",\n  darkturquoise: \"#00ced1\",\n  peachpuff: \"#ffdab9\",\n  deeppink: \"#ff1493\",\n  violet: \"#ee82ee\",\n  palegreen: \"#98fb98\",\n  mediumseagreen: \"#3cb371\",\n  peru: \"#cd853f\",\n  saddlebrown: \"#8b4513\",\n  sandybrown: \"#f4a460\",\n  rosybrown: \"#bc8f8f\",\n  purple: \"#800080\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  papayawhip: \"#ffefd5\",\n  mediumslateblue: \"#7b68ee\",\n  plum: \"#dda0dd\",\n  mediumspringgreen: \"#00fa9a\"\n};\nfunction d(t) {\n  return t < 0 ? 0 : t > 255 ? 255 : Math.round(t) || 0;\n}\nfunction f(t) {\n  return t <= 0 || t > 0 ? t < 0 ? 0 : t > 1 ? 1 : Math.round(1e4 * t) / 1e4 : 0;\n}\nconst p = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i,\n  v = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i,\n  m = /^rgb\\(\\s*(-?\\d{1,10})\\s*,\\s*(-?\\d{1,10})\\s*,\\s*(-?\\d{1,10})\\s*\\)$/,\n  b = /^rgba\\(\\s*(-?\\d{1,10})\\s*,\\s*(-?\\d{1,10})\\s*,\\s*(-?\\d{1,10})\\s*,\\s*(-?[\\d]{0,10}(?:\\.\\d+)?)\\s*\\)$/;\nfunction g(t) {\n  (t = t.toLowerCase()) in c && (t = c[t]);\n  {\n    const i = b.exec(t) || m.exec(t);\n    if (i) return [d(parseInt(i[1], 10)), d(parseInt(i[2], 10)), d(parseInt(i[3], 10)), f(i.length < 5 ? 1 : parseFloat(i[4]))];\n  }\n  {\n    const i = v.exec(t);\n    if (i) return [d(parseInt(i[1], 16)), d(parseInt(i[2], 16)), d(parseInt(i[3], 16)), 1];\n  }\n  {\n    const i = p.exec(t);\n    if (i) return [d(17 * parseInt(i[1], 16)), d(17 * parseInt(i[2], 16)), d(17 * parseInt(i[3], 16)), 1];\n  }\n  throw new Error(\"Cannot parse color: \".concat(t));\n}\nfunction w(t) {\n  const i = g(t);\n  return {\n    t: \"rgb(\".concat(i[0], \", \").concat(i[1], \", \").concat(i[2], \")\"),\n    i: (n = i, .199 * n[0] + .687 * n[1] + .114 * n[2] > 160 ? \"black\" : \"white\")\n  };\n  var n;\n}\nclass M {\n  constructor() {\n    this.h = [];\n  }\n  l(t, i, n) {\n    const s = {\n      o: t,\n      _: i,\n      u: !0 === n\n    };\n    this.h.push(s);\n  }\n  p(t) {\n    const i = this.h.findIndex(i => t === i.o);\n    i > -1 && this.h.splice(i, 1);\n  }\n  v(t) {\n    this.h = this.h.filter(i => i._ !== t);\n  }\n  m(t, i, n) {\n    const s = [...this.h];\n    this.h = this.h.filter(t => !t.u), s.forEach(s => s.o(t, i, n));\n  }\n  g() {\n    return this.h.length > 0;\n  }\n  M() {\n    this.h = [];\n  }\n}\nfunction S(t) {\n  for (var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    i[_key - 1] = arguments[_key];\n  }\n  for (const n of i) for (const i in n) void 0 !== n[i] && (\"object\" != typeof n[i] || void 0 === t[i] ? t[i] = n[i] : S(t[i], n[i]));\n  return t;\n}\nfunction x(t) {\n  return \"number\" == typeof t && isFinite(t);\n}\nfunction y(t) {\n  return \"number\" == typeof t && t % 1 == 0;\n}\nfunction k(t) {\n  return \"string\" == typeof t;\n}\nfunction C(t) {\n  return \"boolean\" == typeof t;\n}\nfunction T(t) {\n  const i = t;\n  if (!i || \"object\" != typeof i) return i;\n  let n, s, e;\n  for (s in n = Array.isArray(i) ? [] : {}, i) i.hasOwnProperty(s) && (e = i[s], n[s] = e && \"object\" == typeof e ? T(e) : e);\n  return n;\n}\nfunction P(t) {\n  return null !== t;\n}\nfunction R(t) {\n  return null === t ? void 0 : t;\n}\nconst D = \"-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif\";\nfunction B(t, i, n) {\n  return void 0 === i && (i = D), \"\".concat(n = void 0 !== n ? \"\".concat(n, \" \") : \"\").concat(t, \"px \").concat(i);\n}\nclass O {\n  constructor(t) {\n    this.S = {\n      k: 1,\n      C: 5,\n      T: NaN,\n      P: \"\",\n      R: \"\",\n      D: \"\",\n      B: \"\",\n      O: 0,\n      A: 0,\n      L: 0,\n      I: 0,\n      V: 0\n    }, this.N = t;\n  }\n  F() {\n    const t = this.S,\n      i = this.W(),\n      n = this.j();\n    return t.T === i && t.R === n || (t.T = i, t.R = n, t.P = B(i, n), t.I = 2.5 / 12 * i, t.O = t.I, t.A = i / 12 * t.C, t.L = i / 12 * t.C, t.V = 0), t.D = this.$(), t.B = this.H(), this.S;\n  }\n  $() {\n    return this.N.F().layout.textColor;\n  }\n  H() {\n    return this.N.U();\n  }\n  W() {\n    return this.N.F().layout.fontSize;\n  }\n  j() {\n    return this.N.F().layout.fontFamily;\n  }\n}\nclass A {\n  constructor() {\n    this.q = [];\n  }\n  Y(t) {\n    this.q = t;\n  }\n  X(t, i, n) {\n    this.q.forEach(s => {\n      s.X(t, i, n);\n    });\n  }\n}\nclass L {\n  X(t, i, n) {\n    t.useMediaCoordinateSpace(t => this.Z(t, i, n));\n  }\n  K(t, i, n) {\n    t.useMediaCoordinateSpace(t => this.G(t, i, n));\n  }\n  G(t, i, n) {}\n}\nclass I extends L {\n  constructor() {\n    super(...arguments), this.J = null;\n  }\n  tt(t) {\n    this.J = t;\n  }\n  Z(_ref) {\n    let {\n      context: t\n    } = _ref;\n    if (null === this.J || null === this.J.it) return;\n    const i = this.J.it,\n      n = this.J,\n      s = s => {\n        t.beginPath();\n        for (let e = i.to - 1; e >= i.from; --e) {\n          const i = n.nt[e];\n          t.moveTo(i.st, i.et), t.arc(i.st, i.et, s, 0, 2 * Math.PI);\n        }\n        t.fill();\n      };\n    n.rt > 0 && (t.fillStyle = n.ht, s(n.lt + n.rt)), t.fillStyle = n.ot, s(n.lt);\n  }\n}\nfunction E() {\n  return {\n    nt: [{\n      st: 0,\n      et: 0,\n      _t: 0,\n      ut: 0\n    }],\n    ot: \"\",\n    ht: \"\",\n    lt: 0,\n    rt: 0,\n    it: null\n  };\n}\nconst V = {\n  from: 0,\n  to: 1\n};\nclass z {\n  constructor(t, i) {\n    this.ct = new A(), this.dt = [], this.ft = [], this.vt = !0, this.N = t, this.bt = i, this.ct.Y(this.dt);\n  }\n  gt(t) {\n    const i = this.N.wt();\n    i.length !== this.dt.length && (this.ft = i.map(E), this.dt = this.ft.map(t => {\n      const i = new I();\n      return i.tt(t), i;\n    }), this.ct.Y(this.dt)), this.vt = !0;\n  }\n  Mt() {\n    return this.vt && (this.St(), this.vt = !1), this.ct;\n  }\n  St() {\n    const t = this.N.wt(),\n      i = this.bt.xt(),\n      n = this.N.yt();\n    t.forEach((t, s) => {\n      var e;\n      const r = this.ft[s],\n        h = t.kt(i);\n      if (null === h || !t.Ct()) return void (r.it = null);\n      const l = _(t.Tt());\n      r.ot = h.Pt, r.lt = h.lt, r.rt = h.Rt, r.nt[0].ut = h.ut, r.nt[0].et = t.Bt().Dt(h.ut, l.Ot), r.ht = null !== (e = h.At) && void 0 !== e ? e : this.N.Lt(r.nt[0].et / t.Bt().It()), r.nt[0]._t = i, r.nt[0].st = n.Et(i), r.it = V;\n    });\n  }\n}\nclass N {\n  X(t, i, n) {\n    t.useBitmapCoordinateSpace(t => this.Z(t, i, n));\n  }\n}\nclass F extends N {\n  constructor(t) {\n    super(), this.Vt = t;\n  }\n  Z(_ref2) {\n    let {\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: n,\n      verticalPixelRatio: s\n    } = _ref2;\n    if (null === this.Vt) return;\n    const e = this.Vt.zt.Ct,\n      r = this.Vt.Nt.Ct;\n    if (!e && !r) return;\n    const a = Math.round(this.Vt.st * n),\n      o = Math.round(this.Vt.et * s);\n    t.lineCap = \"butt\", e && a >= 0 && (t.lineWidth = Math.floor(this.Vt.zt.rt * n), t.strokeStyle = this.Vt.zt.D, t.fillStyle = this.Vt.zt.D, h(t, this.Vt.zt.Ft), function (t, i, n, s) {\n      t.beginPath();\n      const e = t.lineWidth % 2 ? .5 : 0;\n      t.moveTo(i + e, n), t.lineTo(i + e, s), t.stroke();\n    }(t, a, 0, i.height)), r && o >= 0 && (t.lineWidth = Math.floor(this.Vt.Nt.rt * s), t.strokeStyle = this.Vt.Nt.D, t.fillStyle = this.Vt.Nt.D, h(t, this.Vt.Nt.Ft), l(t, o, 0, i.width));\n  }\n}\nclass W {\n  constructor(t) {\n    this.vt = !0, this.Wt = {\n      zt: {\n        rt: 1,\n        Ft: 0,\n        D: \"\",\n        Ct: !1\n      },\n      Nt: {\n        rt: 1,\n        Ft: 0,\n        D: \"\",\n        Ct: !1\n      },\n      st: 0,\n      et: 0\n    }, this.jt = new F(this.Wt), this.$t = t;\n  }\n  gt() {\n    this.vt = !0;\n  }\n  Mt() {\n    return this.vt && (this.St(), this.vt = !1), this.jt;\n  }\n  St() {\n    const t = this.$t.Ct(),\n      i = _(this.$t.Ht()),\n      n = i.Ut().F().crosshair,\n      s = this.Wt;\n    s.Nt.Ct = t && this.$t.qt(i), s.zt.Ct = t && this.$t.Yt(), s.Nt.rt = n.horzLine.width, s.Nt.Ft = n.horzLine.style, s.Nt.D = n.horzLine.color, s.zt.rt = n.vertLine.width, s.zt.Ft = n.vertLine.style, s.zt.D = n.vertLine.color, s.st = this.$t.Xt(), s.et = this.$t.Zt();\n  }\n}\nfunction j(t, i, n, s, e, r) {\n  t.fillRect(i + r, n, s - 2 * r, r), t.fillRect(i + r, n + e - r, s - 2 * r, r), t.fillRect(i, n, r, e), t.fillRect(i + s - r, n, r, e);\n}\nfunction $(t, i, n, s, e, r) {\n  t.save(), t.globalCompositeOperation = \"copy\", t.fillStyle = r, t.fillRect(i, n, s, e), t.restore();\n}\nfunction H(t, i) {\n  return Array.isArray(t) ? t.map(t => 0 === t ? t : t + i) : t + i;\n}\nfunction U(t, i, n, s, e, r) {\n  let h, l, a, o;\n  if (Array.isArray(r)) {\n    if (2 === r.length) {\n      const t = Math.max(0, r[0]),\n        i = Math.max(0, r[1]);\n      h = t, l = t, a = i, o = i;\n    } else {\n      if (4 !== r.length) throw new Error(\"Wrong border radius - it should be like css border radius\");\n      h = Math.max(0, r[0]), l = Math.max(0, r[1]), a = Math.max(0, r[2]), o = Math.max(0, r[3]);\n    }\n  } else {\n    const t = Math.max(0, r);\n    h = t, l = t, a = t, o = t;\n  }\n  t.beginPath(), t.moveTo(i + h, n), t.lineTo(i + s - l, n), 0 !== l && t.arcTo(i + s, n, i + s, n + l, l), t.lineTo(i + s, n + e - a), 0 !== a && t.arcTo(i + s, n + e, i + s - a, n + e, a), t.lineTo(i + o, n + e), 0 !== o && t.arcTo(i, n + e, i, n + e - o, o), t.lineTo(i, n + h), 0 !== h && t.arcTo(i, n, i + h, n, h);\n}\nfunction q(t, i, n, s, e, r) {\n  let h = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let l = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  let a = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : \"\";\n  if (t.save(), !h || !a || a === r) return U(t, i, n, s, e, l), t.fillStyle = r, t.fill(), void t.restore();\n  const o = h / 2;\n  if (\"transparent\" !== r) {\n    U(t, i + h, n + h, s - 2 * h, e - 2 * h, H(l, -h)), t.fillStyle = r, t.fill();\n  }\n  if (\"transparent\" !== a) {\n    U(t, i + o, n + o, s - h, e - h, H(l, -o)), t.lineWidth = h, t.strokeStyle = a, t.closePath(), t.stroke();\n  }\n  t.restore();\n}\nfunction Y(t, i, n, s, e, r, h) {\n  t.save(), t.globalCompositeOperation = \"copy\";\n  const l = t.createLinearGradient(0, 0, 0, e);\n  l.addColorStop(0, r), l.addColorStop(1, h), t.fillStyle = l, t.fillRect(i, n, s, e), t.restore();\n}\nclass X {\n  constructor(t, i) {\n    this.tt(t, i);\n  }\n  tt(t, i) {\n    this.Vt = t, this.Kt = i;\n  }\n  It(t, i) {\n    return this.Vt.Ct ? t.T + t.I + t.O : 0;\n  }\n  X(t, i, n, s) {\n    if (!this.Vt.Ct || 0 === this.Vt.Gt.length) return;\n    const e = this.Vt.D || this.Kt.D,\n      r = this.Kt.t,\n      h = t.useBitmapCoordinateSpace(t => {\n        const h = t.context;\n        h.font = i.P;\n        const l = this.Jt(t, i, n, s),\n          a = l.Qt,\n          o = (t, i) => {\n            l.ti ? q(h, a.ii, a.ni, a.si, a.ei, t, a.ri, [a.lt, 0, 0, a.lt], i) : q(h, a.hi, a.ni, a.si, a.ei, t, a.ri, [0, a.lt, a.lt, 0], i);\n          };\n        return o(r, \"transparent\"), this.Vt.li && (h.fillStyle = e, h.fillRect(a.hi, a.ai, a.oi - a.hi, a._i)), o(\"transparent\", r), this.Vt.ui && (h.fillStyle = i.B, h.fillRect(l.ti ? a.ci - a.ri : 0, a.ni, a.ri, a.di - a.ni)), l;\n      });\n    t.useMediaCoordinateSpace(_ref3 => {\n      let {\n        context: t\n      } = _ref3;\n      const n = h.fi;\n      t.font = i.P, t.textAlign = h.ti ? \"right\" : \"left\", t.textBaseline = \"middle\", t.fillStyle = e, t.fillText(this.Vt.Gt, n.pi, (n.ni + n.di) / 2 + n.vi);\n    });\n  }\n  Jt(t, i, n, s) {\n    var e;\n    const {\n        context: r,\n        bitmapSize: h,\n        mediaSize: l,\n        horizontalPixelRatio: a,\n        verticalPixelRatio: o\n      } = t,\n      _ = this.Vt.li || !this.Vt.mi ? i.C : 0,\n      u = this.Vt.bi ? i.k : 0,\n      c = i.I + this.Kt.gi,\n      d = i.O + this.Kt.wi,\n      f = i.A,\n      p = i.L,\n      v = this.Vt.Gt,\n      m = i.T,\n      b = n.Mi(r, v),\n      g = Math.ceil(n.Si(r, v)),\n      w = m + c + d,\n      M = i.k + f + p + g + _,\n      S = Math.max(1, Math.floor(o));\n    let x = Math.round(w * o);\n    x % 2 != S % 2 && (x += 1);\n    const y = u > 0 ? Math.max(1, Math.floor(u * a)) : 0,\n      k = Math.round(M * a),\n      C = Math.round(_ * a),\n      T = null !== (e = this.Kt.xi) && void 0 !== e ? e : this.Kt.yi,\n      P = Math.round(T * o) - Math.floor(.5 * o),\n      R = Math.floor(P + S / 2 - x / 2),\n      D = R + x,\n      B = \"right\" === s,\n      O = B ? l.width - u : u,\n      A = B ? h.width - y : y;\n    let L, I, E;\n    return B ? (L = A - k, I = A - C, E = O - _ - f - u) : (L = A + k, I = A + C, E = O + _ + f), {\n      ti: B,\n      Qt: {\n        ni: R,\n        ai: P,\n        di: D,\n        si: k,\n        ei: x,\n        lt: 2 * a,\n        ri: y,\n        ii: L,\n        hi: A,\n        oi: I,\n        _i: S,\n        ci: h.width\n      },\n      fi: {\n        ni: R / o,\n        di: D / o,\n        pi: E,\n        vi: b\n      }\n    };\n  }\n}\nclass Z {\n  constructor(t) {\n    this.ki = {\n      yi: 0,\n      D: \"#FFF\",\n      t: \"#000\",\n      wi: 0,\n      gi: 0\n    }, this.Ci = {\n      Gt: \"\",\n      Ct: !1,\n      li: !0,\n      mi: !1,\n      At: \"\",\n      D: \"#FFF\",\n      ui: !1,\n      bi: !1\n    }, this.Ti = {\n      Gt: \"\",\n      Ct: !1,\n      li: !1,\n      mi: !0,\n      At: \"\",\n      D: \"#FFF\",\n      ui: !0,\n      bi: !0\n    }, this.vt = !0, this.Pi = new (t || X)(this.Ci, this.ki), this.Ri = new (t || X)(this.Ti, this.ki);\n  }\n  Gt() {\n    return this.Di(), this.Ci.Gt;\n  }\n  yi() {\n    return this.Di(), this.ki.yi;\n  }\n  gt() {\n    this.vt = !0;\n  }\n  It(t) {\n    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n    return Math.max(this.Pi.It(t, i), this.Ri.It(t, i));\n  }\n  Bi() {\n    return this.ki.xi || 0;\n  }\n  Oi(t) {\n    this.ki.xi = t;\n  }\n  Ai() {\n    return this.Di(), this.Ci.Ct || this.Ti.Ct;\n  }\n  Li() {\n    return this.Di(), this.Ci.Ct;\n  }\n  Mt(t) {\n    return this.Di(), this.Ci.li = this.Ci.li && t.F().ticksVisible, this.Ti.li = this.Ti.li && t.F().ticksVisible, this.Pi.tt(this.Ci, this.ki), this.Ri.tt(this.Ti, this.ki), this.Pi;\n  }\n  Ii() {\n    return this.Di(), this.Pi.tt(this.Ci, this.ki), this.Ri.tt(this.Ti, this.ki), this.Ri;\n  }\n  Di() {\n    this.vt && (this.Ci.li = !0, this.Ti.li = !1, this.Ei(this.Ci, this.Ti, this.ki));\n  }\n}\nclass K extends Z {\n  constructor(t, i, n) {\n    super(), this.$t = t, this.Vi = i, this.zi = n;\n  }\n  Ei(t, i, n) {\n    t.Ct = !1;\n    const s = this.$t.F().horzLine;\n    if (!s.labelVisible) return;\n    const e = this.Vi.Tt();\n    if (!this.$t.Ct() || this.Vi.Ni() || null === e) return;\n    const r = w(s.labelBackgroundColor);\n    n.t = r.t, n.D = r.i;\n    const h = 2 / 12 * this.Vi.T();\n    n.gi = h, n.wi = h;\n    const l = this.zi(this.Vi);\n    n.yi = l.yi, t.Gt = this.Vi.Fi(l.ut, e), t.Ct = !0;\n  }\n}\nconst G = /[1-9]/g;\nclass J {\n  constructor() {\n    this.Vt = null;\n  }\n  tt(t) {\n    this.Vt = t;\n  }\n  X(t, i) {\n    if (null === this.Vt || !1 === this.Vt.Ct || 0 === this.Vt.Gt.length) return;\n    const n = t.useMediaCoordinateSpace(_ref4 => {\n      let {\n        context: t\n      } = _ref4;\n      return t.font = i.P, Math.round(i.Wi.Si(t, _(this.Vt).Gt, G));\n    });\n    if (n <= 0) return;\n    const s = i.ji,\n      e = n + 2 * s,\n      r = e / 2,\n      h = this.Vt.$i;\n    let l = this.Vt.yi,\n      a = Math.floor(l - r) + .5;\n    a < 0 ? (l += Math.abs(0 - a), a = Math.floor(l - r) + .5) : a + e > h && (l -= Math.abs(h - (a + e)), a = Math.floor(l - r) + .5);\n    const o = a + e,\n      u = Math.ceil(0 + i.k + i.C + i.I + i.T + i.O);\n    t.useBitmapCoordinateSpace(_ref5 => {\n      let {\n        context: t,\n        horizontalPixelRatio: n,\n        verticalPixelRatio: s\n      } = _ref5;\n      const e = _(this.Vt);\n      t.fillStyle = e.t;\n      const r = Math.round(a * n),\n        h = Math.round(0 * s),\n        l = Math.round(o * n),\n        c = Math.round(u * s),\n        d = Math.round(2 * n);\n      if (t.beginPath(), t.moveTo(r, h), t.lineTo(r, c - d), t.arcTo(r, c, r + d, c, d), t.lineTo(l - d, c), t.arcTo(l, c, l, c - d, d), t.lineTo(l, h), t.fill(), e.li) {\n        const r = Math.round(e.yi * n),\n          l = h,\n          a = Math.round((l + i.C) * s);\n        t.fillStyle = e.D;\n        const o = Math.max(1, Math.floor(n)),\n          _ = Math.floor(.5 * n);\n        t.fillRect(r - _, l, o, a - l);\n      }\n    }), t.useMediaCoordinateSpace(_ref6 => {\n      let {\n        context: t\n      } = _ref6;\n      const n = _(this.Vt),\n        e = 0 + i.k + i.C + i.I + i.T / 2;\n      t.font = i.P, t.textAlign = \"left\", t.textBaseline = \"middle\", t.fillStyle = n.D;\n      const r = i.Wi.Mi(t, \"Apr0\");\n      t.translate(a + s, e + r), t.fillText(n.Gt, 0, 0);\n    });\n  }\n}\nclass Q {\n  constructor(t, i, n) {\n    this.vt = !0, this.jt = new J(), this.Wt = {\n      Ct: !1,\n      t: \"#4c525e\",\n      D: \"white\",\n      Gt: \"\",\n      $i: 0,\n      yi: NaN,\n      li: !0\n    }, this.bt = t, this.Hi = i, this.zi = n;\n  }\n  gt() {\n    this.vt = !0;\n  }\n  Mt() {\n    return this.vt && (this.St(), this.vt = !1), this.jt.tt(this.Wt), this.jt;\n  }\n  St() {\n    const t = this.Wt;\n    t.Ct = !1;\n    const i = this.bt.F().vertLine;\n    if (!i.labelVisible) return;\n    const n = this.Hi.yt();\n    if (n.Ni()) return;\n    t.$i = n.$i();\n    const s = this.zi();\n    if (null === s) return;\n    t.yi = s.yi;\n    const e = n.Ui(this.bt.xt());\n    t.Gt = n.qi(_(e)), t.Ct = !0;\n    const r = w(i.labelBackgroundColor);\n    t.t = r.t, t.D = r.i, t.li = n.F().ticksVisible;\n  }\n}\nclass tt {\n  constructor() {\n    this.Yi = null, this.Xi = 0;\n  }\n  Zi() {\n    return this.Xi;\n  }\n  Ki(t) {\n    this.Xi = t;\n  }\n  Bt() {\n    return this.Yi;\n  }\n  Gi(t) {\n    this.Yi = t;\n  }\n  Ji(t) {\n    return [];\n  }\n  Qi() {\n    return [];\n  }\n  Ct() {\n    return !0;\n  }\n}\nvar it;\n!function (t) {\n  t[t.Normal = 0] = \"Normal\", t[t.Magnet = 1] = \"Magnet\";\n}(it || (it = {}));\nclass nt extends tt {\n  constructor(t, i) {\n    super(), this.tn = null, this.nn = NaN, this.sn = 0, this.en = !0, this.rn = new Map(), this.hn = !1, this.ln = NaN, this.an = NaN, this.on = NaN, this._n = NaN, this.Hi = t, this.un = i, this.cn = new z(t, this);\n    this.dn = ((t, i) => n => {\n      const s = i(),\n        e = t();\n      if (n === _(this.tn).fn()) return {\n        ut: e,\n        yi: s\n      };\n      {\n        const t = _(n.Tt());\n        return {\n          ut: n.pn(s, t),\n          yi: s\n        };\n      }\n    })(() => this.nn, () => this.an);\n    const n = ((t, i) => () => {\n      const n = this.Hi.yt().vn(t()),\n        s = i();\n      return n && Number.isFinite(s) ? {\n        _t: n,\n        yi: s\n      } : null;\n    })(() => this.sn, () => this.Xt());\n    this.mn = new Q(this, t, n), this.bn = new W(this);\n  }\n  F() {\n    return this.un;\n  }\n  gn(t, i) {\n    this.on = t, this._n = i;\n  }\n  wn() {\n    this.on = NaN, this._n = NaN;\n  }\n  Mn() {\n    return this.on;\n  }\n  Sn() {\n    return this._n;\n  }\n  xn(t, i, n) {\n    this.hn || (this.hn = !0), this.en = !0, this.yn(t, i, n);\n  }\n  xt() {\n    return this.sn;\n  }\n  Xt() {\n    return this.ln;\n  }\n  Zt() {\n    return this.an;\n  }\n  Ct() {\n    return this.en;\n  }\n  kn() {\n    this.en = !1, this.Cn(), this.nn = NaN, this.ln = NaN, this.an = NaN, this.tn = null, this.wn();\n  }\n  Tn(t) {\n    return null !== this.tn ? [this.bn, this.cn] : [];\n  }\n  qt(t) {\n    return t === this.tn && this.un.horzLine.visible;\n  }\n  Yt() {\n    return this.un.vertLine.visible;\n  }\n  Pn(t, i) {\n    this.en && this.tn === t || this.rn.clear();\n    const n = [];\n    return this.tn === t && n.push(this.Rn(this.rn, i, this.dn)), n;\n  }\n  Qi() {\n    return this.en ? [this.mn] : [];\n  }\n  Ht() {\n    return this.tn;\n  }\n  Dn() {\n    this.bn.gt(), this.rn.forEach(t => t.gt()), this.mn.gt(), this.cn.gt();\n  }\n  Bn(t) {\n    return t && !t.fn().Ni() ? t.fn() : null;\n  }\n  yn(t, i, n) {\n    this.On(t, i, n) && this.Dn();\n  }\n  On(t, i, n) {\n    const s = this.ln,\n      e = this.an,\n      r = this.nn,\n      h = this.sn,\n      l = this.tn,\n      a = this.Bn(n);\n    this.sn = t, this.ln = isNaN(t) ? NaN : this.Hi.yt().Et(t), this.tn = n;\n    const o = null !== a ? a.Tt() : null;\n    return null !== a && null !== o ? (this.nn = i, this.an = a.Dt(i, o)) : (this.nn = NaN, this.an = NaN), s !== this.ln || e !== this.an || h !== this.sn || r !== this.nn || l !== this.tn;\n  }\n  Cn() {\n    const t = this.Hi.wt().map(t => t.Ln().An()).filter(P),\n      i = 0 === t.length ? null : Math.max(...t);\n    this.sn = null !== i ? i : NaN;\n  }\n  Rn(t, i, n) {\n    let s = t.get(i);\n    return void 0 === s && (s = new K(this, i, n), t.set(i, s)), s;\n  }\n}\nfunction st(t) {\n  return \"left\" === t || \"right\" === t;\n}\nclass et {\n  constructor(t) {\n    this.In = new Map(), this.En = [], this.Vn = t;\n  }\n  zn(t, i) {\n    const n = function (t, i) {\n      return void 0 === t ? i : {\n        Nn: Math.max(t.Nn, i.Nn),\n        Fn: t.Fn || i.Fn\n      };\n    }(this.In.get(t), i);\n    this.In.set(t, n);\n  }\n  Wn() {\n    return this.Vn;\n  }\n  jn(t) {\n    const i = this.In.get(t);\n    return void 0 === i ? {\n      Nn: this.Vn\n    } : {\n      Nn: Math.max(this.Vn, i.Nn),\n      Fn: i.Fn\n    };\n  }\n  $n() {\n    this.Hn(), this.En = [{\n      Un: 0\n    }];\n  }\n  qn(t) {\n    this.Hn(), this.En = [{\n      Un: 1,\n      Ot: t\n    }];\n  }\n  Yn(t) {\n    this.Xn(), this.En.push({\n      Un: 5,\n      Ot: t\n    });\n  }\n  Hn() {\n    this.Xn(), this.En.push({\n      Un: 6\n    });\n  }\n  Zn() {\n    this.Hn(), this.En = [{\n      Un: 4\n    }];\n  }\n  Kn(t) {\n    this.Hn(), this.En.push({\n      Un: 2,\n      Ot: t\n    });\n  }\n  Gn(t) {\n    this.Hn(), this.En.push({\n      Un: 3,\n      Ot: t\n    });\n  }\n  Jn() {\n    return this.En;\n  }\n  Qn(t) {\n    for (const i of t.En) this.ts(i);\n    this.Vn = Math.max(this.Vn, t.Vn), t.In.forEach((t, i) => {\n      this.zn(i, t);\n    });\n  }\n  static ns() {\n    return new et(2);\n  }\n  static ss() {\n    return new et(3);\n  }\n  ts(t) {\n    switch (t.Un) {\n      case 0:\n        this.$n();\n        break;\n      case 1:\n        this.qn(t.Ot);\n        break;\n      case 2:\n        this.Kn(t.Ot);\n        break;\n      case 3:\n        this.Gn(t.Ot);\n        break;\n      case 4:\n        this.Zn();\n        break;\n      case 5:\n        this.Yn(t.Ot);\n        break;\n      case 6:\n        this.Xn();\n    }\n  }\n  Xn() {\n    const t = this.En.findIndex(t => 5 === t.Un);\n    -1 !== t && this.En.splice(t, 1);\n  }\n}\nconst rt = \".\";\nfunction ht(t, i) {\n  if (!x(t)) return \"n/a\";\n  if (!y(i)) throw new TypeError(\"invalid length\");\n  if (i < 0 || i > 16) throw new TypeError(\"invalid length\");\n  if (0 === i) return t.toString();\n  return (\"0000000000000000\" + t.toString()).slice(-i);\n}\nclass lt {\n  constructor(t, i) {\n    if (i || (i = 1), x(t) && y(t) || (t = 100), t < 0) throw new TypeError(\"invalid base\");\n    this.Vi = t, this.es = i, this.rs();\n  }\n  format(t) {\n    const i = t < 0 ? \"âˆ’\" : \"\";\n    return t = Math.abs(t), i + this.hs(t);\n  }\n  rs() {\n    if (this.ls = 0, this.Vi > 0 && this.es > 0) {\n      let t = this.Vi;\n      for (; t > 1;) t /= 10, this.ls++;\n    }\n  }\n  hs(t) {\n    const i = this.Vi / this.es;\n    let n = Math.floor(t),\n      s = \"\";\n    const e = void 0 !== this.ls ? this.ls : NaN;\n    if (i > 1) {\n      let r = +(Math.round(t * i) - n * i).toFixed(this.ls);\n      r >= i && (r -= i, n += 1), s = rt + ht(+r.toFixed(this.ls) * this.es, e);\n    } else n = Math.round(n * i) / i, e > 0 && (s = rt + ht(0, e));\n    return n.toFixed(0) + s;\n  }\n}\nclass at extends lt {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n    super(t);\n  }\n  format(t) {\n    return \"\".concat(super.format(t), \"%\");\n  }\n}\nclass ot {\n  constructor(t) {\n    this.os = t;\n  }\n  format(t) {\n    let i = \"\";\n    return t < 0 && (i = \"-\", t = -t), t < 995 ? i + this._s(t) : t < 999995 ? i + this._s(t / 1e3) + \"K\" : t < 999999995 ? (t = 1e3 * Math.round(t / 1e3), i + this._s(t / 1e6) + \"M\") : (t = 1e6 * Math.round(t / 1e6), i + this._s(t / 1e9) + \"B\");\n  }\n  _s(t) {\n    let i;\n    const n = Math.pow(10, this.os);\n    return i = (t = Math.round(t * n) / n) >= 1e-15 && t < 1 ? t.toFixed(this.os).replace(/\\.?0+$/, \"\") : String(t), i.replace(/(\\.[1-9]*)0+$/, (t, i) => i);\n  }\n}\nfunction _t(t, i, n, s, e, r, h) {\n  if (0 === i.length || s.from >= i.length) return;\n  const l = t.context,\n    a = i[s.from];\n  let o = r(t, a),\n    _ = a;\n  if (s.to - s.from < 2) {\n    const t = e / 2;\n    l.beginPath();\n    const i = {\n        st: a.st - t,\n        et: a.et\n      },\n      n = {\n        st: a.st + t,\n        et: a.et\n      };\n    return l.moveTo(i.st, i.et), l.lineTo(n.st, n.et), void h(l, o, i, n);\n  }\n  const u = (t, i) => {\n    h(l, o, _, i), l.beginPath(), o = t, _ = i;\n  };\n  let c = _;\n  l.beginPath(), l.moveTo(a.st, a.et);\n  for (let e = s.from + 1; e < s.to; ++e) {\n    c = i[e];\n    const s = r(t, c);\n    switch (n) {\n      case 0:\n        l.lineTo(c.st, c.et);\n        break;\n      case 1:\n        l.lineTo(c.st, i[e - 1].et), s !== o && (u(s, c), l.lineTo(c.st, i[e - 1].et)), l.lineTo(c.st, c.et);\n        break;\n      case 2:\n        {\n          const [t, n] = dt(i, e - 1, e);\n          l.bezierCurveTo(t.st, t.et, n.st, n.et, c.st, c.et);\n          break;\n        }\n    }\n    1 !== n && s !== o && (u(s, c), l.moveTo(c.st, c.et));\n  }\n  (_ !== c || _ === c && 1 === n) && h(l, o, _, c);\n}\nfunction ut(t, i) {\n  return {\n    st: t.st - i.st,\n    et: t.et - i.et\n  };\n}\nfunction ct(t, i) {\n  return {\n    st: t.st / i,\n    et: t.et / i\n  };\n}\nfunction dt(t, i, n) {\n  const s = Math.max(0, i - 1),\n    e = Math.min(t.length - 1, n + 1);\n  var r, h;\n  return [(r = t[i], h = ct(ut(t[n], t[s]), 6), {\n    st: r.st + h.st,\n    et: r.et + h.et\n  }), ut(t[n], ct(ut(t[e], t[i]), 6))];\n}\nfunction ft(t, i, n, s, e) {\n  i.lineTo(e.st, t), i.lineTo(s.st, t), i.closePath(), i.fillStyle = n, i.fill();\n}\nclass pt extends L {\n  constructor() {\n    super(...arguments), this.J = null;\n  }\n  tt(t) {\n    this.J = t;\n  }\n  Z(t) {\n    var i;\n    if (null === this.J) return;\n    const {\n        nt: n,\n        it: s,\n        us: e,\n        rt: r,\n        Ft: l,\n        cs: a\n      } = this.J,\n      o = null !== (i = this.J.ds) && void 0 !== i ? i : this.J.fs ? 0 : t.mediaSize.height;\n    if (null === s) return;\n    const _ = t.context;\n    _.lineCap = \"butt\", _.lineJoin = \"round\", _.lineWidth = r, h(_, l), _.lineWidth = 1, _t(t, n, a, s, e, this.ps.bind(this), ft.bind(null, o));\n  }\n}\nclass vt extends pt {\n  constructor() {\n    super(...arguments), this.vs = null;\n  }\n  ps(t, i) {\n    const {\n        context: n,\n        mediaSize: s\n      } = t,\n      {\n        bs: e,\n        gs: r\n      } = i,\n      h = s.height;\n    if (null !== this.vs && this.vs.topColor === e && this.vs.bottomColor === r && this.vs.bottom === h) return this.vs.fillStyle;\n    const l = n.createLinearGradient(0, 0, 0, h);\n    return l.addColorStop(0, e), l.addColorStop(1, r), this.vs = {\n      topColor: e,\n      bottomColor: r,\n      fillStyle: l,\n      bottom: h\n    }, l;\n  }\n}\nfunction mt(t, i) {\n  t.strokeStyle = i, t.stroke();\n}\nclass bt extends L {\n  constructor() {\n    super(...arguments), this.J = null;\n  }\n  tt(t) {\n    this.J = t;\n  }\n  Z(t) {\n    if (null === this.J) return;\n    const {\n      nt: i,\n      it: n,\n      us: s,\n      cs: e,\n      rt: r,\n      Ft: l\n    } = this.J;\n    if (null === n) return;\n    const a = t.context;\n    a.lineCap = \"butt\", a.lineWidth = r, h(a, l), a.lineJoin = \"round\", _t(t, i, e, n, s, this.ws.bind(this), mt);\n  }\n}\nclass gt extends bt {\n  ws(t, i) {\n    return i.ot;\n  }\n}\nfunction wt(t, i, n) {\n  let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : t.length;\n  let r = e - s;\n  for (; 0 < r;) {\n    const e = r >> 1,\n      h = s + e;\n    n(t[h], i) ? (s = h + 1, r -= e + 1) : r = e;\n  }\n  return s;\n}\nfunction Mt(t, i, n) {\n  let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : t.length;\n  let r = e - s;\n  for (; 0 < r;) {\n    const e = r >> 1,\n      h = s + e;\n    n(i, t[h]) ? r = e : (s = h + 1, r -= e + 1);\n  }\n  return s;\n}\nfunction St(t, i) {\n  return t._t < i;\n}\nfunction xt(t, i) {\n  return t < i._t;\n}\nfunction yt(t, i, n) {\n  const s = i.Ms(),\n    e = i.ci(),\n    r = wt(t, s, St),\n    h = Mt(t, e, xt);\n  if (!n) return {\n    from: r,\n    to: h\n  };\n  let l = r,\n    a = h;\n  return r > 0 && r < t.length && t[r]._t >= s && (l = r - 1), h > 0 && h < t.length && t[h - 1]._t <= e && (a = h + 1), {\n    from: l,\n    to: a\n  };\n}\nclass kt {\n  constructor(t, i, n) {\n    this.Ss = !0, this.xs = !0, this.ys = !0, this.ks = [], this.Cs = null, this.Ts = t, this.Ps = i, this.Rs = n;\n  }\n  gt(t) {\n    this.Ss = !0, \"data\" === t && (this.xs = !0), \"options\" === t && (this.ys = !0);\n  }\n  Mt() {\n    return this.Ts.Ct() ? (this.Ds(), null === this.Cs ? null : this.Bs) : null;\n  }\n  Os() {\n    this.ks = this.ks.map(t => Object.assign(Object.assign({}, t), this.Ts.Ls().As(t._t)));\n  }\n  Is() {\n    this.Cs = null;\n  }\n  Ds() {\n    this.xs && (this.Es(), this.xs = !1), this.ys && (this.Os(), this.ys = !1), this.Ss && (this.Vs(), this.Ss = !1);\n  }\n  Vs() {\n    const t = this.Ts.Bt(),\n      i = this.Ps.yt();\n    if (this.Is(), i.Ni() || t.Ni()) return;\n    const n = i.zs();\n    if (null === n) return;\n    if (0 === this.Ts.Ln().Ns()) return;\n    const s = this.Ts.Tt();\n    null !== s && (this.Cs = yt(this.ks, n, this.Rs), this.Fs(t, i, s.Ot), this.Ws());\n  }\n}\nclass Ct extends kt {\n  constructor(t, i) {\n    super(t, i, !0);\n  }\n  Fs(t, i, n) {\n    i.js(this.ks, R(this.Cs)), t.$s(this.ks, n, R(this.Cs));\n  }\n  Hs(t, i) {\n    return {\n      _t: t,\n      ut: i,\n      st: NaN,\n      et: NaN\n    };\n  }\n  Es() {\n    const t = this.Ts.Ls();\n    this.ks = this.Ts.Ln().Us().map(i => {\n      const n = i.Ot[3];\n      return this.qs(i.Ys, n, t);\n    });\n  }\n}\nclass Tt extends Ct {\n  constructor(t, i) {\n    super(t, i), this.Bs = new A(), this.Xs = new vt(), this.Zs = new gt(), this.Bs.Y([this.Xs, this.Zs]);\n  }\n  qs(t, i, n) {\n    return Object.assign(Object.assign({}, this.Hs(t, i)), n.As(t));\n  }\n  Ws() {\n    const t = this.Ts.F();\n    this.Xs.tt({\n      cs: t.lineType,\n      nt: this.ks,\n      Ft: t.lineStyle,\n      rt: t.lineWidth,\n      ds: null,\n      fs: t.invertFilledArea,\n      it: this.Cs,\n      us: this.Ps.yt().Ks()\n    }), this.Zs.tt({\n      cs: t.lineType,\n      nt: this.ks,\n      Ft: t.lineStyle,\n      rt: t.lineWidth,\n      it: this.Cs,\n      us: this.Ps.yt().Ks()\n    });\n  }\n}\nclass Pt extends N {\n  constructor() {\n    super(...arguments), this.Vt = null, this.Gs = 0, this.Js = 0;\n  }\n  tt(t) {\n    this.Vt = t;\n  }\n  Z(_ref7) {\n    let {\n      context: t,\n      horizontalPixelRatio: i,\n      verticalPixelRatio: n\n    } = _ref7;\n    if (null === this.Vt || 0 === this.Vt.Ln.length || null === this.Vt.it) return;\n    if (this.Gs = this.Qs(i), this.Gs >= 2) {\n      Math.max(1, Math.floor(i)) % 2 != this.Gs % 2 && this.Gs--;\n    }\n    this.Js = this.Vt.te ? Math.min(this.Gs, Math.floor(i)) : this.Gs;\n    let s = null;\n    const e = this.Js <= this.Gs && this.Vt.Ks >= Math.floor(1.5 * i);\n    for (let r = this.Vt.it.from; r < this.Vt.it.to; ++r) {\n      const h = this.Vt.Ln[r];\n      s !== h.ie && (t.fillStyle = h.ie, s = h.ie);\n      const l = Math.floor(.5 * this.Js),\n        a = Math.round(h.st * i),\n        o = a - l,\n        _ = this.Js,\n        u = o + _ - 1,\n        c = Math.min(h.ne, h.se),\n        d = Math.max(h.ne, h.se),\n        f = Math.round(c * n) - l,\n        p = Math.round(d * n) + l,\n        v = Math.max(p - f, this.Js);\n      t.fillRect(o, f, _, v);\n      const m = Math.ceil(1.5 * this.Gs);\n      if (e) {\n        if (this.Vt.ee) {\n          const i = a - m;\n          let s = Math.max(f, Math.round(h.re * n) - l),\n            e = s + _ - 1;\n          e > f + v - 1 && (e = f + v - 1, s = e - _ + 1), t.fillRect(i, s, o - i, e - s + 1);\n        }\n        const i = a + m;\n        let s = Math.max(f, Math.round(h.he * n) - l),\n          e = s + _ - 1;\n        e > f + v - 1 && (e = f + v - 1, s = e - _ + 1), t.fillRect(u + 1, s, i - u, e - s + 1);\n      }\n    }\n  }\n  Qs(t) {\n    const i = Math.floor(t);\n    return Math.max(i, Math.floor(function (t, i) {\n      return Math.floor(.3 * t * i);\n    }(_(this.Vt).Ks, t)));\n  }\n}\nclass Rt extends kt {\n  constructor(t, i) {\n    super(t, i, !1);\n  }\n  Fs(t, i, n) {\n    i.js(this.ks, R(this.Cs)), t.le(this.ks, n, R(this.Cs));\n  }\n  ae(t, i, n) {\n    return {\n      _t: t,\n      oe: i.Ot[0],\n      _e: i.Ot[1],\n      ue: i.Ot[2],\n      ce: i.Ot[3],\n      st: NaN,\n      re: NaN,\n      ne: NaN,\n      se: NaN,\n      he: NaN\n    };\n  }\n  Es() {\n    const t = this.Ts.Ls();\n    this.ks = this.Ts.Ln().Us().map(i => this.qs(i.Ys, i, t));\n  }\n}\nclass Dt extends Rt {\n  constructor() {\n    super(...arguments), this.Bs = new Pt();\n  }\n  qs(t, i, n) {\n    return Object.assign(Object.assign({}, this.ae(t, i, n)), n.As(t));\n  }\n  Ws() {\n    const t = this.Ts.F();\n    this.Bs.tt({\n      Ln: this.ks,\n      Ks: this.Ps.yt().Ks(),\n      ee: t.openVisible,\n      te: t.thinBars,\n      it: this.Cs\n    });\n  }\n}\nfunction Bt(t, i, n) {\n  return Math.min(Math.max(t, i), n);\n}\nfunction Ot(t, i, n) {\n  return i - t <= n;\n}\nfunction At(t) {\n  return t <= 0 ? NaN : Math.log(t) / Math.log(10);\n}\nfunction Lt(t) {\n  const i = Math.ceil(t);\n  return i % 2 == 0 ? i - 1 : i;\n}\nclass It extends pt {\n  constructor() {\n    super(...arguments), this.vs = null;\n  }\n  ps(t, i) {\n    var n;\n    const {\n        context: s,\n        mediaSize: e\n      } = t,\n      r = this.J,\n      {\n        de: h,\n        fe: l,\n        pe: a,\n        ve: o\n      } = i,\n      _ = null !== (n = r.ds) && void 0 !== n ? n : e.height,\n      u = e.height;\n    if (null !== this.vs && this.vs.topFillColor1 === h && this.vs.topFillColor2 === l && this.vs.bottomFillColor1 === a && this.vs.bottomFillColor2 === o && this.vs.baseLevelCoordinate === _ && this.vs.bottom === u) return this.vs.fillStyle;\n    const c = s.createLinearGradient(0, 0, 0, u),\n      d = Bt(_ / u, 0, 1);\n    return c.addColorStop(0, h), c.addColorStop(d, l), c.addColorStop(d, a), c.addColorStop(1, o), this.vs = {\n      topFillColor1: h,\n      topFillColor2: l,\n      bottomFillColor1: a,\n      bottomFillColor2: o,\n      fillStyle: c,\n      baseLevelCoordinate: _,\n      bottom: u\n    }, c;\n  }\n}\nclass Et extends bt {\n  constructor() {\n    super(...arguments), this.me = null;\n  }\n  ws(t, i) {\n    const {\n        context: n,\n        mediaSize: s\n      } = t,\n      e = this.J,\n      {\n        be: r,\n        ge: h\n      } = i,\n      {\n        ds: l\n      } = e,\n      a = s.height;\n    if (null !== this.me && this.me.topLineColor === r && this.me.bottomLineColor === h && this.me.baseLevelCoordinate === l && this.me.bottom === a) return this.me.strokeStyle;\n    const o = n.createLinearGradient(0, 0, 0, a),\n      _ = Bt(l / a, 0, 1);\n    return o.addColorStop(0, r), o.addColorStop(_, r), o.addColorStop(_, h), o.addColorStop(1, h), this.me = {\n      topLineColor: r,\n      bottomLineColor: h,\n      strokeStyle: o,\n      baseLevelCoordinate: l,\n      bottom: a\n    }, o;\n  }\n}\nclass Vt extends Ct {\n  constructor(t, i) {\n    super(t, i), this.Bs = new A(), this.we = new It(), this.Me = new Et(), this.Bs.Y([this.we, this.Me]);\n  }\n  qs(t, i, n) {\n    return Object.assign(Object.assign({}, this.Hs(t, i)), n.As(t));\n  }\n  Ws() {\n    const t = this.Ts.Tt();\n    if (null === t) return;\n    const i = this.Ts.F(),\n      n = this.Ts.Bt().Dt(i.baseValue.price, t.Ot),\n      s = this.Ps.yt().Ks();\n    this.we.tt({\n      nt: this.ks,\n      rt: i.lineWidth,\n      Ft: i.lineStyle,\n      cs: i.lineType,\n      ds: n,\n      fs: !1,\n      it: this.Cs,\n      us: s\n    }), this.Me.tt({\n      nt: this.ks,\n      rt: i.lineWidth,\n      Ft: i.lineStyle,\n      cs: i.lineType,\n      ds: n,\n      it: this.Cs,\n      us: s\n    });\n  }\n}\nclass zt extends N {\n  constructor() {\n    super(...arguments), this.Vt = null, this.Gs = 0;\n  }\n  tt(t) {\n    this.Vt = t;\n  }\n  Z(t) {\n    if (null === this.Vt || 0 === this.Vt.Ln.length || null === this.Vt.it) return;\n    const {\n      horizontalPixelRatio: i\n    } = t;\n    if (this.Gs = function (t, i) {\n      if (t >= 2.5 && t <= 4) return Math.floor(3 * i);\n      const n = 1 - .2 * Math.atan(Math.max(4, t) - 4) / (.5 * Math.PI),\n        s = Math.floor(t * n * i),\n        e = Math.floor(t * i),\n        r = Math.min(s, e);\n      return Math.max(Math.floor(i), r);\n    }(this.Vt.Ks, i), this.Gs >= 2) {\n      Math.floor(i) % 2 != this.Gs % 2 && this.Gs--;\n    }\n    const n = this.Vt.Ln;\n    this.Vt.Se && this.xe(t, n, this.Vt.it), this.Vt.ui && this.ye(t, n, this.Vt.it);\n    const s = this.ke(i);\n    (!this.Vt.ui || this.Gs > 2 * s) && this.Ce(t, n, this.Vt.it);\n  }\n  xe(t, i, n) {\n    if (null === this.Vt) return;\n    const {\n      context: s,\n      horizontalPixelRatio: e,\n      verticalPixelRatio: r\n    } = t;\n    let h = \"\",\n      l = Math.min(Math.floor(e), Math.floor(this.Vt.Ks * e));\n    l = Math.max(Math.floor(e), Math.min(l, this.Gs));\n    const a = Math.floor(.5 * l);\n    let o = null;\n    for (let t = n.from; t < n.to; t++) {\n      const n = i[t];\n      n.Te !== h && (s.fillStyle = n.Te, h = n.Te);\n      const _ = Math.round(Math.min(n.re, n.he) * r),\n        u = Math.round(Math.max(n.re, n.he) * r),\n        c = Math.round(n.ne * r),\n        d = Math.round(n.se * r);\n      let f = Math.round(e * n.st) - a;\n      const p = f + l - 1;\n      null !== o && (f = Math.max(o + 1, f), f = Math.min(f, p));\n      const v = p - f + 1;\n      s.fillRect(f, c, v, _ - c), s.fillRect(f, u + 1, v, d - u), o = p;\n    }\n  }\n  ke(t) {\n    let i = Math.floor(1 * t);\n    this.Gs <= 2 * i && (i = Math.floor(.5 * (this.Gs - 1)));\n    const n = Math.max(Math.floor(t), i);\n    return this.Gs <= 2 * n ? Math.max(Math.floor(t), Math.floor(1 * t)) : n;\n  }\n  ye(t, i, n) {\n    if (null === this.Vt) return;\n    const {\n      context: s,\n      horizontalPixelRatio: e,\n      verticalPixelRatio: r\n    } = t;\n    let h = \"\";\n    const l = this.ke(e);\n    let a = null;\n    for (let t = n.from; t < n.to; t++) {\n      const n = i[t];\n      n.Pe !== h && (s.fillStyle = n.Pe, h = n.Pe);\n      let o = Math.round(n.st * e) - Math.floor(.5 * this.Gs);\n      const _ = o + this.Gs - 1,\n        u = Math.round(Math.min(n.re, n.he) * r),\n        c = Math.round(Math.max(n.re, n.he) * r);\n      if (null !== a && (o = Math.max(a + 1, o), o = Math.min(o, _)), this.Vt.Ks * e > 2 * l) j(s, o, u, _ - o + 1, c - u + 1, l);else {\n        const t = _ - o + 1;\n        s.fillRect(o, u, t, c - u + 1);\n      }\n      a = _;\n    }\n  }\n  Ce(t, i, n) {\n    if (null === this.Vt) return;\n    const {\n      context: s,\n      horizontalPixelRatio: e,\n      verticalPixelRatio: r\n    } = t;\n    let h = \"\";\n    const l = this.ke(e);\n    for (let t = n.from; t < n.to; t++) {\n      const n = i[t];\n      let a = Math.round(Math.min(n.re, n.he) * r),\n        o = Math.round(Math.max(n.re, n.he) * r),\n        _ = Math.round(n.st * e) - Math.floor(.5 * this.Gs),\n        u = _ + this.Gs - 1;\n      if (n.ie !== h) {\n        const t = n.ie;\n        s.fillStyle = t, h = t;\n      }\n      this.Vt.ui && (_ += l, a += l, u -= l, o -= l), a > o || s.fillRect(_, a, u - _ + 1, o - a + 1);\n    }\n  }\n}\nclass Nt extends Rt {\n  constructor() {\n    super(...arguments), this.Bs = new zt();\n  }\n  qs(t, i, n) {\n    return Object.assign(Object.assign({}, this.ae(t, i, n)), n.As(t));\n  }\n  Ws() {\n    const t = this.Ts.F();\n    this.Bs.tt({\n      Ln: this.ks,\n      Ks: this.Ps.yt().Ks(),\n      Se: t.wickVisible,\n      ui: t.borderVisible,\n      it: this.Cs\n    });\n  }\n}\nclass Ft extends N {\n  constructor() {\n    super(...arguments), this.Vt = null, this.Re = [];\n  }\n  tt(t) {\n    this.Vt = t, this.Re = [];\n  }\n  Z(_ref8) {\n    let {\n      context: t,\n      horizontalPixelRatio: i,\n      verticalPixelRatio: n\n    } = _ref8;\n    if (null === this.Vt || 0 === this.Vt.nt.length || null === this.Vt.it) return;\n    this.Re.length || this.De(i);\n    const s = Math.max(1, Math.floor(n)),\n      e = Math.round(this.Vt.Be * n) - Math.floor(s / 2),\n      r = e + s;\n    for (let i = this.Vt.it.from; i < this.Vt.it.to; i++) {\n      const h = this.Vt.nt[i],\n        l = this.Re[i - this.Vt.it.from],\n        a = Math.round(h.et * n);\n      let o, _;\n      t.fillStyle = h.ie, a <= e ? (o = a, _ = r) : (o = e, _ = a - Math.floor(s / 2) + s), t.fillRect(l.Ms, o, l.ci - l.Ms + 1, _ - o);\n    }\n  }\n  De(t) {\n    if (null === this.Vt || 0 === this.Vt.nt.length || null === this.Vt.it) return void (this.Re = []);\n    const i = Math.ceil(this.Vt.Ks * t) <= 1 ? 0 : Math.max(1, Math.floor(t)),\n      n = Math.round(this.Vt.Ks * t) - i;\n    this.Re = new Array(this.Vt.it.to - this.Vt.it.from);\n    for (let i = this.Vt.it.from; i < this.Vt.it.to; i++) {\n      const s = this.Vt.nt[i],\n        e = Math.round(s.st * t);\n      let r, h;\n      if (n % 2) {\n        const t = (n - 1) / 2;\n        r = e - t, h = e + t;\n      } else {\n        const t = n / 2;\n        r = e - t, h = e + t - 1;\n      }\n      this.Re[i - this.Vt.it.from] = {\n        Ms: r,\n        ci: h,\n        Oe: e,\n        Ae: s.st * t,\n        _t: s._t\n      };\n    }\n    for (let t = this.Vt.it.from + 1; t < this.Vt.it.to; t++) {\n      const n = this.Re[t - this.Vt.it.from],\n        s = this.Re[t - this.Vt.it.from - 1];\n      n._t === s._t + 1 && n.Ms - s.ci !== i + 1 && (s.Oe > s.Ae ? s.ci = n.Ms - i - 1 : n.Ms = s.ci + i + 1);\n    }\n    let s = Math.ceil(this.Vt.Ks * t);\n    for (let t = this.Vt.it.from; t < this.Vt.it.to; t++) {\n      const i = this.Re[t - this.Vt.it.from];\n      i.ci < i.Ms && (i.ci = i.Ms);\n      const n = i.ci - i.Ms + 1;\n      s = Math.min(n, s);\n    }\n    if (i > 0 && s < 4) for (let t = this.Vt.it.from; t < this.Vt.it.to; t++) {\n      const i = this.Re[t - this.Vt.it.from];\n      i.ci - i.Ms + 1 > s && (i.Oe > i.Ae ? i.ci -= 1 : i.Ms += 1);\n    }\n  }\n}\nclass Wt extends Ct {\n  constructor() {\n    super(...arguments), this.Bs = new Ft();\n  }\n  qs(t, i, n) {\n    return Object.assign(Object.assign({}, this.Hs(t, i)), n.As(t));\n  }\n  Ws() {\n    const t = {\n      nt: this.ks,\n      Ks: this.Ps.yt().Ks(),\n      it: this.Cs,\n      Be: this.Ts.Bt().Dt(this.Ts.F().base, _(this.Ts.Tt()).Ot)\n    };\n    this.Bs.tt(t);\n  }\n}\nclass jt extends Ct {\n  constructor() {\n    super(...arguments), this.Bs = new gt();\n  }\n  qs(t, i, n) {\n    return Object.assign(Object.assign({}, this.Hs(t, i)), n.As(t));\n  }\n  Ws() {\n    const t = this.Ts.F(),\n      i = {\n        nt: this.ks,\n        Ft: t.lineStyle,\n        cs: t.lineType,\n        rt: t.lineWidth,\n        it: this.Cs,\n        us: this.Ps.yt().Ks()\n      };\n    this.Bs.tt(i);\n  }\n}\nconst $t = /[2-9]/g;\nclass Ht {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    this.Le = 0, this.Ie = 1, this.Ee = 1, this.Ve = {}, this.ze = new Map(), this.Ne = t;\n  }\n  Fe() {\n    this.Le = 0, this.ze.clear(), this.Ie = 1, this.Ee = 1, this.Ve = {};\n  }\n  Si(t, i, n) {\n    return this.We(t, i, n).width;\n  }\n  Mi(t, i, n) {\n    const s = this.We(t, i, n);\n    return ((s.actualBoundingBoxAscent || 0) - (s.actualBoundingBoxDescent || 0)) / 2;\n  }\n  We(t, i, n) {\n    const s = n || $t,\n      e = String(i).replace(s, \"0\");\n    if (this.ze.has(e)) return o(this.ze.get(e)).je;\n    if (this.Le === this.Ne) {\n      const t = this.Ve[this.Ee];\n      delete this.Ve[this.Ee], this.ze.delete(t), this.Ee++, this.Le--;\n    }\n    t.save(), t.textBaseline = \"middle\";\n    const r = t.measureText(e);\n    return t.restore(), 0 === r.width && i.length || (this.ze.set(e, {\n      je: r,\n      $e: this.Ie\n    }), this.Ve[this.Ie] = e, this.Le++, this.Ie++), r;\n  }\n}\nclass Ut {\n  constructor(t) {\n    this.He = null, this.S = null, this.Ue = \"right\", this.qe = t;\n  }\n  Ye(t, i, n) {\n    this.He = t, this.S = i, this.Ue = n;\n  }\n  X(t) {\n    null !== this.S && null !== this.He && this.He.X(t, this.S, this.qe, this.Ue);\n  }\n}\nclass qt {\n  constructor(t, i, n) {\n    this.Xe = t, this.qe = new Ht(50), this.Ze = i, this.N = n, this.W = -1, this.jt = new Ut(this.qe);\n  }\n  Mt() {\n    const t = this.N.Ke(this.Ze);\n    if (null === t) return null;\n    const i = t.Ge(this.Ze) ? t.Je() : this.Ze.Bt();\n    if (null === i) return null;\n    const n = t.Qe(i);\n    if (\"overlay\" === n) return null;\n    const s = this.N.tr();\n    return s.T !== this.W && (this.W = s.T, this.qe.Fe()), this.jt.Ye(this.Xe.Ii(), s, n), this.jt;\n  }\n}\nclass Yt extends N {\n  constructor() {\n    super(...arguments), this.Vt = null;\n  }\n  tt(t) {\n    this.Vt = t;\n  }\n  ir(t, i) {\n    var n;\n    if (!(null === (n = this.Vt) || void 0 === n ? void 0 : n.Ct)) return null;\n    const {\n      et: s,\n      rt: e,\n      nr: r\n    } = this.Vt;\n    return i >= s - e - 7 && i <= s + e + 7 ? {\n      sr: this.Vt,\n      nr: r\n    } : null;\n  }\n  Z(_ref9) {\n    let {\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: n,\n      verticalPixelRatio: s\n    } = _ref9;\n    if (null === this.Vt) return;\n    if (!1 === this.Vt.Ct) return;\n    const e = Math.round(this.Vt.et * s);\n    e < 0 || e > i.height || (t.lineCap = \"butt\", t.strokeStyle = this.Vt.D, t.lineWidth = Math.floor(this.Vt.rt * n), h(t, this.Vt.Ft), l(t, e, 0, i.width));\n  }\n}\nclass Xt {\n  constructor(t) {\n    this.er = {\n      et: 0,\n      D: \"rgba(0, 0, 0, 0)\",\n      rt: 1,\n      Ft: 0,\n      Ct: !1\n    }, this.rr = new Yt(), this.vt = !0, this.Ts = t, this.Ps = t.Ut(), this.rr.tt(this.er);\n  }\n  gt() {\n    this.vt = !0;\n  }\n  Mt() {\n    return this.Ts.Ct() ? (this.vt && (this.hr(), this.vt = !1), this.rr) : null;\n  }\n}\nclass Zt extends Xt {\n  constructor(t) {\n    super(t);\n  }\n  hr() {\n    this.er.Ct = !1;\n    const t = this.Ts.Bt(),\n      i = t.lr().lr;\n    if (2 !== i && 3 !== i) return;\n    const n = this.Ts.F();\n    if (!n.baseLineVisible || !this.Ts.Ct()) return;\n    const s = this.Ts.Tt();\n    null !== s && (this.er.Ct = !0, this.er.et = t.Dt(s.Ot, s.Ot), this.er.D = n.baseLineColor, this.er.rt = n.baseLineWidth, this.er.Ft = n.baseLineStyle);\n  }\n}\nclass Kt extends N {\n  constructor() {\n    super(...arguments), this.Vt = null;\n  }\n  tt(t) {\n    this.Vt = t;\n  }\n  ar() {\n    return this.Vt;\n  }\n  Z(_ref0) {\n    let {\n      context: t,\n      horizontalPixelRatio: i,\n      verticalPixelRatio: n\n    } = _ref0;\n    const s = this.Vt;\n    if (null === s) return;\n    const e = Math.max(1, Math.floor(i)),\n      r = e % 2 / 2,\n      h = Math.round(s.Ae.x * i) + r,\n      l = s.Ae.y * n;\n    t.fillStyle = s._r, t.beginPath();\n    const a = Math.max(2, 1.5 * s.ur) * i;\n    t.arc(h, l, a, 0, 2 * Math.PI, !1), t.fill(), t.fillStyle = s.cr, t.beginPath(), t.arc(h, l, s.lt * i, 0, 2 * Math.PI, !1), t.fill(), t.lineWidth = e, t.strokeStyle = s.dr, t.beginPath(), t.arc(h, l, s.lt * i + e / 2, 0, 2 * Math.PI, !1), t.stroke();\n  }\n}\nconst Gt = [{\n  pr: 0,\n  vr: .25,\n  mr: 4,\n  br: 10,\n  gr: .25,\n  wr: 0,\n  Mr: .4,\n  Sr: .8\n}, {\n  pr: .25,\n  vr: .525,\n  mr: 10,\n  br: 14,\n  gr: 0,\n  wr: 0,\n  Mr: .8,\n  Sr: 0\n}, {\n  pr: .525,\n  vr: 1,\n  mr: 14,\n  br: 14,\n  gr: 0,\n  wr: 0,\n  Mr: 0,\n  Sr: 0\n}];\nfunction Jt(t, i, n, s) {\n  return function (t, i) {\n    if (\"transparent\" === t) return t;\n    const n = g(t),\n      s = n[3];\n    return \"rgba(\".concat(n[0], \", \").concat(n[1], \", \").concat(n[2], \", \").concat(i * s, \")\");\n  }(t, n + (s - n) * i);\n}\nfunction Qt(t, i) {\n  const n = t % 2600 / 2600;\n  let s;\n  for (const t of Gt) if (n >= t.pr && n <= t.vr) {\n    s = t;\n    break;\n  }\n  a(void 0 !== s, \"Last price animation internal logic error\");\n  const e = (n - s.pr) / (s.vr - s.pr);\n  return {\n    cr: Jt(i, e, s.gr, s.wr),\n    dr: Jt(i, e, s.Mr, s.Sr),\n    lt: (r = e, h = s.mr, l = s.br, h + (l - h) * r)\n  };\n  var r, h, l;\n}\nclass ti {\n  constructor(t) {\n    this.jt = new Kt(), this.vt = !0, this.yr = !0, this.kr = performance.now(), this.Cr = this.kr - 1, this.Tr = t;\n  }\n  Pr() {\n    this.Cr = this.kr - 1, this.gt();\n  }\n  Rr() {\n    if (this.gt(), 2 === this.Tr.F().lastPriceAnimation) {\n      const t = performance.now(),\n        i = this.Cr - t;\n      if (i > 0) return void (i < 650 && (this.Cr += 2600));\n      this.kr = t, this.Cr = t + 2600;\n    }\n  }\n  gt() {\n    this.vt = !0;\n  }\n  Dr() {\n    this.yr = !0;\n  }\n  Ct() {\n    return 0 !== this.Tr.F().lastPriceAnimation;\n  }\n  Br() {\n    switch (this.Tr.F().lastPriceAnimation) {\n      case 0:\n        return !1;\n      case 1:\n        return !0;\n      case 2:\n        return performance.now() <= this.Cr;\n    }\n  }\n  Mt() {\n    return this.vt ? (this.St(), this.vt = !1, this.yr = !1) : this.yr && (this.Or(), this.yr = !1), this.jt;\n  }\n  St() {\n    this.jt.tt(null);\n    const t = this.Tr.Ut().yt(),\n      i = t.zs(),\n      n = this.Tr.Tt();\n    if (null === i || null === n) return;\n    const s = this.Tr.Ar(!0);\n    if (s.Lr || !i.Ir(s.Ys)) return;\n    const e = {\n        x: t.Et(s.Ys),\n        y: this.Tr.Bt().Dt(s.ut, n.Ot)\n      },\n      r = s.D,\n      h = this.Tr.F().lineWidth,\n      l = Qt(this.Er(), r);\n    this.jt.tt({\n      _r: r,\n      ur: h,\n      cr: l.cr,\n      dr: l.dr,\n      lt: l.lt,\n      Ae: e\n    });\n  }\n  Or() {\n    const t = this.jt.ar();\n    if (null !== t) {\n      const i = Qt(this.Er(), t._r);\n      t.cr = i.cr, t.dr = i.dr, t.lt = i.lt;\n    }\n  }\n  Er() {\n    return this.Br() ? performance.now() - this.kr : 2599;\n  }\n}\nfunction ii(t, i) {\n  return Lt(Math.min(Math.max(t, 12), 30) * i);\n}\nfunction ni(t, i) {\n  switch (t) {\n    case \"arrowDown\":\n    case \"arrowUp\":\n      return ii(i, 1);\n    case \"circle\":\n      return ii(i, .8);\n    case \"square\":\n      return ii(i, .7);\n  }\n}\nfunction si(t) {\n  return function (t) {\n    const i = Math.ceil(t);\n    return i % 2 != 0 ? i - 1 : i;\n  }(ii(t, 1));\n}\nfunction ei(t) {\n  return Math.max(ii(t, .1), 3);\n}\nfunction ri(t, i, n, s, e) {\n  const r = ni(\"square\", n),\n    h = (r - 1) / 2,\n    l = t - h,\n    a = i - h;\n  return s >= l && s <= l + r && e >= a && e <= a + r;\n}\nfunction hi(t, i, n, s, e) {\n  const r = (ni(\"arrowUp\", e) - 1) / 2,\n    h = (Lt(e / 2) - 1) / 2;\n  i.beginPath(), t ? (i.moveTo(n - r, s), i.lineTo(n, s - r), i.lineTo(n + r, s), i.lineTo(n + h, s), i.lineTo(n + h, s + r), i.lineTo(n - h, s + r), i.lineTo(n - h, s)) : (i.moveTo(n - r, s), i.lineTo(n, s + r), i.lineTo(n + r, s), i.lineTo(n + h, s), i.lineTo(n + h, s - r), i.lineTo(n - h, s - r), i.lineTo(n - h, s)), i.fill();\n}\nfunction li(t, i, n, s, e, r) {\n  return ri(i, n, s, e, r);\n}\nclass ai extends L {\n  constructor() {\n    super(...arguments), this.Vt = null, this.qe = new Ht(), this.W = -1, this.j = \"\", this.Vr = \"\";\n  }\n  tt(t) {\n    this.Vt = t;\n  }\n  Ye(t, i) {\n    this.W === t && this.j === i || (this.W = t, this.j = i, this.Vr = B(t, i), this.qe.Fe());\n  }\n  ir(t, i) {\n    if (null === this.Vt || null === this.Vt.it) return null;\n    for (let n = this.Vt.it.from; n < this.Vt.it.to; n++) {\n      const s = this.Vt.nt[n];\n      if (_i(s, t, i)) return {\n        sr: s.zr,\n        nr: s.nr\n      };\n    }\n    return null;\n  }\n  Z(_ref1, i, n) {\n    let {\n      context: t\n    } = _ref1;\n    if (null !== this.Vt && null !== this.Vt.it) {\n      t.textBaseline = \"middle\", t.font = this.Vr;\n      for (let i = this.Vt.it.from; i < this.Vt.it.to; i++) {\n        const n = this.Vt.nt[i];\n        void 0 !== n.Gt && (n.Gt.$i = this.qe.Si(t, n.Gt.Nr), n.Gt.It = this.W), oi(n, t);\n      }\n    }\n  }\n}\nfunction oi(t, i) {\n  i.fillStyle = t.D, void 0 !== t.Gt && function (t, i, n, s) {\n    t.fillText(i, n, s);\n  }(i, t.Gt.Nr, t.st - t.Gt.$i / 2, t.Gt.et), function (t, i) {\n    if (0 === t.Ns) return;\n    switch (t.Fr) {\n      case \"arrowDown\":\n        return void hi(!1, i, t.st, t.et, t.Ns);\n      case \"arrowUp\":\n        return void hi(!0, i, t.st, t.et, t.Ns);\n      case \"circle\":\n        return void function (t, i, n, s) {\n          const e = (ni(\"circle\", s) - 1) / 2;\n          t.beginPath(), t.arc(i, n, e, 0, 2 * Math.PI, !1), t.fill();\n        }(i, t.st, t.et, t.Ns);\n      case \"square\":\n        return void function (t, i, n, s) {\n          const e = ni(\"square\", s),\n            r = (e - 1) / 2,\n            h = i - r,\n            l = n - r;\n          t.fillRect(h, l, e, e);\n        }(i, t.st, t.et, t.Ns);\n    }\n    t.Fr;\n  }(t, i);\n}\nfunction _i(t, i, n) {\n  return !(void 0 === t.Gt || !function (t, i, n, s, e, r) {\n    const h = s / 2;\n    return e >= t && e <= t + n && r >= i - h && r <= i + h;\n  }(t.st, t.Gt.et, t.Gt.$i, t.Gt.It, i, n)) || function (t, i, n) {\n    if (0 === t.Ns) return !1;\n    switch (t.Fr) {\n      case \"arrowDown\":\n      case \"arrowUp\":\n        return li(0, t.st, t.et, t.Ns, i, n);\n      case \"circle\":\n        return function (t, i, n, s, e) {\n          const r = 2 + ni(\"circle\", n) / 2,\n            h = t - s,\n            l = i - e;\n          return Math.sqrt(h * h + l * l) <= r;\n        }(t.st, t.et, t.Ns, i, n);\n      case \"square\":\n        return ri(t.st, t.et, t.Ns, i, n);\n    }\n  }(t, i, n);\n}\nfunction ui(t, i, n, s, e, r, h, l, a) {\n  const o = x(n) ? n : n.ce,\n    _ = x(n) ? n : n._e,\n    u = x(n) ? n : n.ue,\n    c = x(i.size) ? Math.max(i.size, 0) : 1,\n    d = si(l.Ks()) * c,\n    f = d / 2;\n  switch (t.Ns = d, i.position) {\n    case \"inBar\":\n      return t.et = h.Dt(o, a), void (void 0 !== t.Gt && (t.Gt.et = t.et + f + r + .6 * e));\n    case \"aboveBar\":\n      return t.et = h.Dt(_, a) - f - s.Wr, void 0 !== t.Gt && (t.Gt.et = t.et - f - .6 * e, s.Wr += 1.2 * e), void (s.Wr += d + r);\n    case \"belowBar\":\n      return t.et = h.Dt(u, a) + f + s.jr, void 0 !== t.Gt && (t.Gt.et = t.et + f + r + .6 * e, s.jr += 1.2 * e), void (s.jr += d + r);\n  }\n  i.position;\n}\nclass ci {\n  constructor(t, i) {\n    this.vt = !0, this.$r = !0, this.Hr = !0, this.Ur = null, this.jt = new ai(), this.Tr = t, this.Hi = i, this.Vt = {\n      nt: [],\n      it: null\n    };\n  }\n  gt(t) {\n    this.vt = !0, this.Hr = !0, \"data\" === t && (this.$r = !0);\n  }\n  Mt(t) {\n    if (!this.Tr.Ct()) return null;\n    this.vt && this.qr();\n    const i = this.Hi.F().layout;\n    return this.jt.Ye(i.fontSize, i.fontFamily), this.jt.tt(this.Vt), this.jt;\n  }\n  Yr() {\n    if (this.Hr) {\n      if (this.Tr.Xr().length > 0) {\n        const t = this.Hi.yt().Ks(),\n          i = ei(t),\n          n = 1.5 * si(t) + 2 * i;\n        this.Ur = {\n          above: n,\n          below: n\n        };\n      } else this.Ur = null;\n      this.Hr = !1;\n    }\n    return this.Ur;\n  }\n  qr() {\n    const t = this.Tr.Bt(),\n      i = this.Hi.yt(),\n      n = this.Tr.Xr();\n    this.$r && (this.Vt.nt = n.map(t => ({\n      _t: t.time,\n      st: 0,\n      et: 0,\n      Ns: 0,\n      Fr: t.shape,\n      D: t.color,\n      zr: t.internalId,\n      nr: t.id,\n      Gt: void 0\n    })), this.$r = !1);\n    const s = this.Hi.F().layout;\n    this.Vt.it = null;\n    const e = i.zs();\n    if (null === e) return;\n    const r = this.Tr.Tt();\n    if (null === r) return;\n    if (0 === this.Vt.nt.length) return;\n    let h = NaN;\n    const l = ei(i.Ks()),\n      a = {\n        Wr: l,\n        jr: l\n      };\n    this.Vt.it = yt(this.Vt.nt, e, !0);\n    for (let e = this.Vt.it.from; e < this.Vt.it.to; e++) {\n      const o = n[e];\n      o.time !== h && (a.Wr = l, a.jr = l, h = o.time);\n      const _ = this.Vt.nt[e];\n      _.st = i.Et(o.time), void 0 !== o.text && o.text.length > 0 && (_.Gt = {\n        Nr: o.text,\n        et: 0,\n        $i: 0,\n        It: 0\n      });\n      const u = this.Tr.Zr(o.time);\n      null !== u && ui(_, o, u, a, s.fontSize, l, t, i, r.Ot);\n    }\n    this.vt = !1;\n  }\n}\nclass di extends Xt {\n  constructor(t) {\n    super(t);\n  }\n  hr() {\n    const t = this.er;\n    t.Ct = !1;\n    const i = this.Ts.F();\n    if (!i.priceLineVisible || !this.Ts.Ct()) return;\n    const n = this.Ts.Ar(0 === i.priceLineSource);\n    n.Lr || (t.Ct = !0, t.et = n.yi, t.D = this.Ts.Kr(n.D), t.rt = i.priceLineWidth, t.Ft = i.priceLineStyle);\n  }\n}\nclass fi extends Z {\n  constructor(t) {\n    super(), this.$t = t;\n  }\n  Ei(t, i, n) {\n    t.Ct = !1, i.Ct = !1;\n    const s = this.$t;\n    if (!s.Ct()) return;\n    const e = s.F(),\n      r = e.lastValueVisible,\n      h = \"\" !== s.Gr(),\n      l = 0 === e.seriesLastValueMode,\n      a = s.Ar(!1);\n    if (a.Lr) return;\n    r && (t.Gt = this.Jr(a, r, l), t.Ct = 0 !== t.Gt.length), (h || l) && (i.Gt = this.Qr(a, r, h, l), i.Ct = i.Gt.length > 0);\n    const o = s.Kr(a.D),\n      _ = w(o);\n    n.t = _.t, n.D = _.i, n.yi = a.yi, i.At = s.Ut().Lt(a.yi / s.Bt().It()), t.At = o, t.D = n.D, i.D = n.D;\n  }\n  Qr(t, i, n, s) {\n    let e = \"\";\n    const r = this.$t.Gr();\n    return n && 0 !== r.length && (e += \"\".concat(r, \" \")), i && s && (e += this.$t.Bt().th() ? t.ih : t.nh), e.trim();\n  }\n  Jr(t, i, n) {\n    return i ? n ? this.$t.Bt().th() ? t.nh : t.ih : t.Gt : \"\";\n  }\n}\nclass pi {\n  constructor(t, i) {\n    this.sh = t, this.eh = i;\n  }\n  rh(t) {\n    return null !== t && this.sh === t.sh && this.eh === t.eh;\n  }\n  hh() {\n    return new pi(this.sh, this.eh);\n  }\n  lh() {\n    return this.sh;\n  }\n  ah() {\n    return this.eh;\n  }\n  oh() {\n    return this.eh - this.sh;\n  }\n  Ni() {\n    return this.eh === this.sh || Number.isNaN(this.eh) || Number.isNaN(this.sh);\n  }\n  Qn(t) {\n    return null === t ? this : new pi(Math.min(this.lh(), t.lh()), Math.max(this.ah(), t.ah()));\n  }\n  _h(t) {\n    if (!x(t)) return;\n    if (0 === this.eh - this.sh) return;\n    const i = .5 * (this.eh + this.sh);\n    let n = this.eh - i,\n      s = this.sh - i;\n    n *= t, s *= t, this.eh = i + n, this.sh = i + s;\n  }\n  uh(t) {\n    x(t) && (this.eh += t, this.sh += t);\n  }\n  dh() {\n    return {\n      minValue: this.sh,\n      maxValue: this.eh\n    };\n  }\n  static fh(t) {\n    return null === t ? null : new pi(t.minValue, t.maxValue);\n  }\n}\nclass vi {\n  constructor(t, i) {\n    this.ph = t, this.mh = i || null;\n  }\n  bh() {\n    return this.ph;\n  }\n  gh() {\n    return this.mh;\n  }\n  dh() {\n    return null === this.ph ? null : {\n      priceRange: this.ph.dh(),\n      margins: this.mh || void 0\n    };\n  }\n  static fh(t) {\n    return null === t ? null : new vi(pi.fh(t.priceRange), t.margins);\n  }\n}\nclass mi extends Xt {\n  constructor(t, i) {\n    super(t), this.wh = i;\n  }\n  hr() {\n    const t = this.er;\n    t.Ct = !1;\n    const i = this.wh.F();\n    if (!this.Ts.Ct() || !i.lineVisible) return;\n    const n = this.wh.Mh();\n    null !== n && (t.Ct = !0, t.et = n, t.D = i.color, t.rt = i.lineWidth, t.Ft = i.lineStyle, t.nr = this.wh.F().id);\n  }\n}\nclass bi extends Z {\n  constructor(t, i) {\n    super(), this.Tr = t, this.wh = i;\n  }\n  Ei(t, i, n) {\n    t.Ct = !1, i.Ct = !1;\n    const s = this.wh.F(),\n      e = s.axisLabelVisible,\n      r = \"\" !== s.title,\n      h = this.Tr;\n    if (!e || !h.Ct()) return;\n    const l = this.wh.Mh();\n    if (null === l) return;\n    r && (i.Gt = s.title, i.Ct = !0), i.At = h.Ut().Lt(l / h.Bt().It()), t.Gt = this.Sh(s.price), t.Ct = !0;\n    const a = w(s.color);\n    n.t = a.t, n.D = a.i, n.yi = l;\n  }\n  Sh(t) {\n    const i = this.Tr.Tt();\n    return null === i ? \"\" : this.Tr.Bt().Fi(t, i.Ot);\n  }\n}\nclass gi {\n  constructor(t, i) {\n    this.Tr = t, this.un = i, this.xh = new mi(t, this), this.Xe = new bi(t, this), this.yh = new qt(this.Xe, t, t.Ut());\n  }\n  kh(t) {\n    S(this.un, t), this.gt(), this.Tr.Ut().Ch();\n  }\n  F() {\n    return this.un;\n  }\n  Th() {\n    return this.xh;\n  }\n  Ph() {\n    return this.yh;\n  }\n  Rh() {\n    return this.Xe;\n  }\n  gt() {\n    this.xh.gt(), this.Xe.gt();\n  }\n  Mh() {\n    const t = this.Tr,\n      i = t.Bt();\n    if (t.Ut().yt().Ni() || i.Ni()) return null;\n    const n = t.Tt();\n    return null === n ? null : i.Dt(this.un.price, n.Ot);\n  }\n}\nclass wi extends tt {\n  constructor(t) {\n    super(), this.Hi = t;\n  }\n  Ut() {\n    return this.Hi;\n  }\n}\nconst Mi = {\n  Bar: (t, i, n, s) => {\n    var e;\n    const r = i.upColor,\n      h = i.downColor,\n      l = _(t(n, s)),\n      a = u(l.Ot[0]) <= u(l.Ot[3]);\n    return {\n      ie: null !== (e = l.D) && void 0 !== e ? e : a ? r : h\n    };\n  },\n  Candlestick: (t, i, n, s) => {\n    var e, r, h;\n    const l = i.upColor,\n      a = i.downColor,\n      o = i.borderUpColor,\n      c = i.borderDownColor,\n      d = i.wickUpColor,\n      f = i.wickDownColor,\n      p = _(t(n, s)),\n      v = u(p.Ot[0]) <= u(p.Ot[3]);\n    return {\n      ie: null !== (e = p.D) && void 0 !== e ? e : v ? l : a,\n      Pe: null !== (r = p.At) && void 0 !== r ? r : v ? o : c,\n      Te: null !== (h = p.Dh) && void 0 !== h ? h : v ? d : f\n    };\n  },\n  Area: (t, i, n, s) => {\n    var e, r, h, l;\n    const a = _(t(n, s));\n    return {\n      ie: null !== (e = a.ot) && void 0 !== e ? e : i.lineColor,\n      ot: null !== (r = a.ot) && void 0 !== r ? r : i.lineColor,\n      bs: null !== (h = a.bs) && void 0 !== h ? h : i.topColor,\n      gs: null !== (l = a.gs) && void 0 !== l ? l : i.bottomColor\n    };\n  },\n  Baseline: (t, i, n, s) => {\n    var e, r, h, l, a, o;\n    const u = _(t(n, s));\n    return {\n      ie: u.Ot[3] >= i.baseValue.price ? i.topLineColor : i.bottomLineColor,\n      be: null !== (e = u.be) && void 0 !== e ? e : i.topLineColor,\n      ge: null !== (r = u.ge) && void 0 !== r ? r : i.bottomLineColor,\n      de: null !== (h = u.de) && void 0 !== h ? h : i.topFillColor1,\n      fe: null !== (l = u.fe) && void 0 !== l ? l : i.topFillColor2,\n      pe: null !== (a = u.pe) && void 0 !== a ? a : i.bottomFillColor1,\n      ve: null !== (o = u.ve) && void 0 !== o ? o : i.bottomFillColor2\n    };\n  },\n  Line: (t, i, n, s) => {\n    var e, r;\n    const h = _(t(n, s));\n    return {\n      ie: null !== (e = h.D) && void 0 !== e ? e : i.color,\n      ot: null !== (r = h.D) && void 0 !== r ? r : i.color\n    };\n  },\n  Histogram: (t, i, n, s) => {\n    var e;\n    return {\n      ie: null !== (e = _(t(n, s)).D) && void 0 !== e ? e : i.color\n    };\n  }\n};\nclass Si {\n  constructor(t) {\n    this.Bh = (t, i) => void 0 !== i ? i.Ot : this.Tr.Ln().Oh(t), this.Tr = t, this.Ah = Mi[t.Lh()];\n  }\n  As(t, i) {\n    return this.Ah(this.Bh, this.Tr.F(), t, i);\n  }\n}\nvar xi;\n!function (t) {\n  t[t.NearestLeft = -1] = \"NearestLeft\", t[t.None = 0] = \"None\", t[t.NearestRight = 1] = \"NearestRight\";\n}(xi || (xi = {}));\nconst yi = 30;\nclass ki {\n  constructor() {\n    this.Ih = [], this.Eh = new Map(), this.Vh = new Map();\n  }\n  zh() {\n    return this.Ns() > 0 ? this.Ih[this.Ih.length - 1] : null;\n  }\n  Nh() {\n    return this.Ns() > 0 ? this.Fh(0) : null;\n  }\n  An() {\n    return this.Ns() > 0 ? this.Fh(this.Ih.length - 1) : null;\n  }\n  Ns() {\n    return this.Ih.length;\n  }\n  Ni() {\n    return 0 === this.Ns();\n  }\n  Ir(t) {\n    return null !== this.Wh(t, 0);\n  }\n  Oh(t) {\n    return this.jh(t);\n  }\n  jh(t) {\n    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const n = this.Wh(t, i);\n    return null === n ? null : Object.assign(Object.assign({}, this.$h(n)), {\n      Ys: this.Fh(n)\n    });\n  }\n  Us() {\n    return this.Ih;\n  }\n  Hh(t, i, n) {\n    if (this.Ni()) return null;\n    let s = null;\n    for (const e of n) {\n      s = Ci(s, this.Uh(t, i, e));\n    }\n    return s;\n  }\n  tt(t) {\n    this.Vh.clear(), this.Eh.clear(), this.Ih = t;\n  }\n  Fh(t) {\n    return this.Ih[t].Ys;\n  }\n  $h(t) {\n    return this.Ih[t];\n  }\n  Wh(t, i) {\n    const n = this.qh(t);\n    if (null === n && 0 !== i) switch (i) {\n      case -1:\n        return this.Yh(t);\n      case 1:\n        return this.Xh(t);\n      default:\n        throw new TypeError(\"Unknown search mode\");\n    }\n    return n;\n  }\n  Yh(t) {\n    let i = this.Zh(t);\n    return i > 0 && (i -= 1), i !== this.Ih.length && this.Fh(i) < t ? i : null;\n  }\n  Xh(t) {\n    const i = this.Kh(t);\n    return i !== this.Ih.length && t < this.Fh(i) ? i : null;\n  }\n  qh(t) {\n    const i = this.Zh(t);\n    return i === this.Ih.length || t < this.Ih[i].Ys ? null : i;\n  }\n  Zh(t) {\n    return wt(this.Ih, t, (t, i) => t.Ys < i);\n  }\n  Kh(t) {\n    return Mt(this.Ih, t, (t, i) => i.Ys > t);\n  }\n  Gh(t, i, n) {\n    let s = null;\n    for (let e = t; e < i; e++) {\n      const t = this.Ih[e].Ot[n];\n      Number.isNaN(t) || (null === s ? s = {\n        Jh: t,\n        Qh: t\n      } : (t < s.Jh && (s.Jh = t), t > s.Qh && (s.Qh = t)));\n    }\n    return s;\n  }\n  Uh(t, i, n) {\n    if (this.Ni()) return null;\n    let s = null;\n    const e = _(this.Nh()),\n      r = _(this.An()),\n      h = Math.max(t, e),\n      l = Math.min(i, r),\n      a = Math.ceil(h / yi) * yi,\n      o = Math.max(a, Math.floor(l / yi) * yi);\n    {\n      const t = this.Zh(h),\n        e = this.Kh(Math.min(l, a, i));\n      s = Ci(s, this.Gh(t, e, n));\n    }\n    let u = this.Eh.get(n);\n    void 0 === u && (u = new Map(), this.Eh.set(n, u));\n    for (let t = Math.max(a + 1, h); t < o; t += yi) {\n      const i = Math.floor(t / yi);\n      let e = u.get(i);\n      if (void 0 === e) {\n        const t = this.Zh(i * yi),\n          s = this.Kh((i + 1) * yi - 1);\n        e = this.Gh(t, s, n), u.set(i, e);\n      }\n      s = Ci(s, e);\n    }\n    {\n      const t = this.Zh(o),\n        i = this.Kh(l);\n      s = Ci(s, this.Gh(t, i, n));\n    }\n    return s;\n  }\n}\nfunction Ci(t, i) {\n  if (null === t) return i;\n  if (null === i) return t;\n  return {\n    Jh: Math.min(t.Jh, i.Jh),\n    Qh: Math.max(t.Qh, i.Qh)\n  };\n}\nclass Ti extends wi {\n  constructor(t, i, n) {\n    super(t), this.Vt = new ki(), this.xh = new di(this), this.tl = [], this.il = new Zt(this), this.nl = null, this.sl = null, this.el = [], this.rl = [], this.hl = null, this.un = i, this.ll = n;\n    const s = new fi(this);\n    this.rn = [s], this.yh = new qt(s, this, t), \"Area\" !== n && \"Line\" !== n && \"Baseline\" !== n || (this.nl = new ti(this)), this.al(), this.ol();\n  }\n  M() {\n    null !== this.hl && clearTimeout(this.hl);\n  }\n  Kr(t) {\n    return this.un.priceLineColor || t;\n  }\n  Ar(t) {\n    const i = {\n        Lr: !0\n      },\n      n = this.Bt();\n    if (this.Ut().yt().Ni() || n.Ni() || this.Vt.Ni()) return i;\n    const s = this.Ut().yt().zs(),\n      e = this.Tt();\n    if (null === s || null === e) return i;\n    let r, h;\n    if (t) {\n      const t = this.Vt.zh();\n      if (null === t) return i;\n      r = t, h = t.Ys;\n    } else {\n      const t = this.Vt.jh(s.ci(), -1);\n      if (null === t) return i;\n      if (r = this.Vt.Oh(t.Ys), null === r) return i;\n      h = t.Ys;\n    }\n    const l = r.Ot[3],\n      a = this.Ls().As(h, {\n        Ot: r\n      }),\n      o = n.Dt(l, e.Ot);\n    return {\n      Lr: !1,\n      ut: l,\n      Gt: n.Fi(l, e.Ot),\n      ih: n._l(l),\n      nh: n.ul(l, e.Ot),\n      D: a.ie,\n      yi: o,\n      Ys: h\n    };\n  }\n  Ls() {\n    return null !== this.sl || (this.sl = new Si(this)), this.sl;\n  }\n  F() {\n    return this.un;\n  }\n  kh(t) {\n    const i = t.priceScaleId;\n    void 0 !== i && i !== this.un.priceScaleId && this.Ut().cl(this, i), S(this.un, t), void 0 !== t.priceFormat && (this.al(), this.Ut().dl()), this.Ut().fl(this), this.Ut().pl(), this.bn.gt(\"options\");\n  }\n  tt(t, i) {\n    this.Vt.tt(t), this.vl(), this.bn.gt(\"data\"), this.cn.gt(\"data\"), null !== this.nl && (i && i.ml ? this.nl.Rr() : 0 === t.length && this.nl.Pr());\n    const n = this.Ut().Ke(this);\n    this.Ut().bl(n), this.Ut().fl(this), this.Ut().pl(), this.Ut().Ch();\n  }\n  gl(t) {\n    this.el = t, this.vl();\n    const i = this.Ut().Ke(this);\n    this.cn.gt(\"data\"), this.Ut().bl(i), this.Ut().fl(this), this.Ut().pl(), this.Ut().Ch();\n  }\n  wl() {\n    return this.el;\n  }\n  Xr() {\n    return this.rl;\n  }\n  Ml(t) {\n    const i = new gi(this, t);\n    return this.tl.push(i), this.Ut().fl(this), i;\n  }\n  Sl(t) {\n    const i = this.tl.indexOf(t);\n    -1 !== i && this.tl.splice(i, 1), this.Ut().fl(this);\n  }\n  Lh() {\n    return this.ll;\n  }\n  Tt() {\n    const t = this.xl();\n    return null === t ? null : {\n      Ot: t.Ot[3],\n      yl: t._t\n    };\n  }\n  xl() {\n    const t = this.Ut().yt().zs();\n    if (null === t) return null;\n    const i = t.Ms();\n    return this.Vt.jh(i, 1);\n  }\n  Ln() {\n    return this.Vt;\n  }\n  Zr(t) {\n    const i = this.Vt.Oh(t);\n    return null === i ? null : \"Bar\" === this.ll || \"Candlestick\" === this.ll ? {\n      oe: i.Ot[0],\n      _e: i.Ot[1],\n      ue: i.Ot[2],\n      ce: i.Ot[3]\n    } : i.Ot[3];\n  }\n  kl(t) {\n    const i = this.nl;\n    return null !== i && i.Ct() ? (null === this.hl && i.Br() && (this.hl = setTimeout(() => {\n      this.hl = null, this.Ut().Cl();\n    }, 0)), i.Dr(), [i]) : [];\n  }\n  Tn() {\n    const t = [];\n    this.Tl() || t.push(this.il), t.push(this.bn, this.xh, this.cn);\n    const i = this.tl.map(t => t.Th());\n    return t.push(...i), t;\n  }\n  Ji(t) {\n    return [this.yh, ...this.tl.map(t => t.Ph())];\n  }\n  Pn(t, i) {\n    if (i !== this.Yi && !this.Tl()) return [];\n    const n = [...this.rn];\n    for (const t of this.tl) n.push(t.Rh());\n    return n;\n  }\n  Pl(t, i) {\n    if (void 0 !== this.un.autoscaleInfoProvider) {\n      const n = this.un.autoscaleInfoProvider(() => {\n        const n = this.Rl(t, i);\n        return null === n ? null : n.dh();\n      });\n      return vi.fh(n);\n    }\n    return this.Rl(t, i);\n  }\n  Dl() {\n    return this.un.priceFormat.minMove;\n  }\n  Bl() {\n    return this.Ol;\n  }\n  Dn() {\n    var t;\n    this.bn.gt(), this.cn.gt();\n    for (const t of this.rn) t.gt();\n    for (const t of this.tl) t.gt();\n    this.xh.gt(), this.il.gt(), null === (t = this.nl) || void 0 === t || t.gt();\n  }\n  Bt() {\n    return _(super.Bt());\n  }\n  kt(t) {\n    if (!((\"Line\" === this.ll || \"Area\" === this.ll || \"Baseline\" === this.ll) && this.un.crosshairMarkerVisible)) return null;\n    const i = this.Vt.Oh(t);\n    if (null === i) return null;\n    return {\n      ut: i.Ot[3],\n      lt: this.Al(),\n      At: this.Ll(),\n      Rt: this.Il(),\n      Pt: this.El(t)\n    };\n  }\n  Gr() {\n    return this.un.title;\n  }\n  Ct() {\n    return this.un.visible;\n  }\n  Tl() {\n    return !st(this.Bt().Vl());\n  }\n  Rl(t, i) {\n    if (!y(t) || !y(i) || this.Vt.Ni()) return null;\n    const n = \"Line\" === this.ll || \"Area\" === this.ll || \"Baseline\" === this.ll || \"Histogram\" === this.ll ? [3] : [2, 1],\n      s = this.Vt.Hh(t, i, n);\n    let e = null !== s ? new pi(s.Jh, s.Qh) : null;\n    if (\"Histogram\" === this.Lh()) {\n      const t = this.un.base,\n        i = new pi(t, t);\n      e = null !== e ? e.Qn(i) : i;\n    }\n    return new vi(e, this.cn.Yr());\n  }\n  Al() {\n    switch (this.ll) {\n      case \"Line\":\n      case \"Area\":\n      case \"Baseline\":\n        return this.un.crosshairMarkerRadius;\n    }\n    return 0;\n  }\n  Ll() {\n    switch (this.ll) {\n      case \"Line\":\n      case \"Area\":\n      case \"Baseline\":\n        {\n          const t = this.un.crosshairMarkerBorderColor;\n          if (0 !== t.length) return t;\n        }\n    }\n    return null;\n  }\n  Il() {\n    switch (this.ll) {\n      case \"Line\":\n      case \"Area\":\n      case \"Baseline\":\n        return this.un.crosshairMarkerBorderWidth;\n    }\n    return 0;\n  }\n  El(t) {\n    switch (this.ll) {\n      case \"Line\":\n      case \"Area\":\n      case \"Baseline\":\n        {\n          const t = this.un.crosshairMarkerBackgroundColor;\n          if (0 !== t.length) return t;\n        }\n    }\n    return this.Ls().As(t).ie;\n  }\n  al() {\n    switch (this.un.priceFormat.type) {\n      case \"custom\":\n        this.Ol = {\n          format: this.un.priceFormat.formatter\n        };\n        break;\n      case \"volume\":\n        this.Ol = new ot(this.un.priceFormat.precision);\n        break;\n      case \"percent\":\n        this.Ol = new at(this.un.priceFormat.precision);\n        break;\n      default:\n        {\n          const t = Math.pow(10, this.un.priceFormat.precision);\n          this.Ol = new lt(t, this.un.priceFormat.minMove * t);\n        }\n    }\n    null !== this.Yi && this.Yi.zl();\n  }\n  vl() {\n    const t = this.Ut().yt();\n    if (t.Ni() || 0 === this.Vt.Ns()) return void (this.rl = []);\n    const i = _(this.Vt.Nh());\n    this.rl = this.el.map((n, s) => {\n      const e = _(t.Nl(n.time, !0)),\n        r = e < i ? 1 : -1;\n      return {\n        time: _(this.Vt.jh(e, r)).Ys,\n        position: n.position,\n        shape: n.shape,\n        color: n.color,\n        id: n.id,\n        internalId: s,\n        text: n.text,\n        size: n.size\n      };\n    });\n  }\n  ol() {\n    switch (this.cn = new ci(this, this.Ut()), this.ll) {\n      case \"Bar\":\n        this.bn = new Dt(this, this.Ut());\n        break;\n      case \"Candlestick\":\n        this.bn = new Nt(this, this.Ut());\n        break;\n      case \"Line\":\n        this.bn = new jt(this, this.Ut());\n        break;\n      case \"Area\":\n        this.bn = new Tt(this, this.Ut());\n        break;\n      case \"Baseline\":\n        this.bn = new Vt(this, this.Ut());\n        break;\n      case \"Histogram\":\n        this.bn = new Wt(this, this.Ut());\n        break;\n      default:\n        throw Error(\"Unknown chart style assigned: \" + this.ll);\n    }\n  }\n}\nclass Pi {\n  constructor(t) {\n    this.un = t;\n  }\n  Fl(t, i, n) {\n    let s = t;\n    if (0 === this.un.mode) return s;\n    const e = n.fn(),\n      r = e.Tt();\n    if (null === r) return s;\n    const h = e.Dt(t, r),\n      l = n.Wl().filter(t => t instanceof Ti).reduce((t, s) => {\n        if (n.Ge(s) || !s.Ct()) return t;\n        const e = s.Bt(),\n          r = s.Ln();\n        if (e.Ni() || !r.Ir(i)) return t;\n        const h = r.Oh(i);\n        if (null === h) return t;\n        const l = u(s.Tt());\n        return t.concat([e.Dt(h.Ot[3], l.Ot)]);\n      }, []);\n    if (0 === l.length) return s;\n    l.sort((t, i) => Math.abs(t - h) - Math.abs(i - h));\n    const a = l[0];\n    return s = e.pn(a, r), s;\n  }\n}\nclass Ri extends N {\n  constructor() {\n    super(...arguments), this.Vt = null;\n  }\n  tt(t) {\n    this.Vt = t;\n  }\n  Z(_ref10) {\n    let {\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: n,\n      verticalPixelRatio: s\n    } = _ref10;\n    if (null === this.Vt) return;\n    const e = Math.max(1, Math.floor(n));\n    t.lineWidth = e, function (t, i) {\n      t.save(), t.lineWidth % 2 && t.translate(.5, .5), i(), t.restore();\n    }(t, () => {\n      const r = _(this.Vt);\n      if (r.jl) {\n        t.strokeStyle = r.$l, h(t, r.Hl), t.beginPath();\n        for (const s of r.Ul) {\n          const r = Math.round(s.ql * n);\n          t.moveTo(r, -e), t.lineTo(r, i.height + e);\n        }\n        t.stroke();\n      }\n      if (r.Yl) {\n        t.strokeStyle = r.Xl, h(t, r.Zl), t.beginPath();\n        for (const n of r.Kl) {\n          const r = Math.round(n.ql * s);\n          t.moveTo(-e, r), t.lineTo(i.width + e, r);\n        }\n        t.stroke();\n      }\n    });\n  }\n}\nclass Di {\n  constructor(t) {\n    this.jt = new Ri(), this.vt = !0, this.tn = t;\n  }\n  gt() {\n    this.vt = !0;\n  }\n  Mt() {\n    if (this.vt) {\n      const t = this.tn.Ut().F().grid,\n        i = {\n          Yl: t.horzLines.visible,\n          jl: t.vertLines.visible,\n          Xl: t.horzLines.color,\n          $l: t.vertLines.color,\n          Zl: t.horzLines.style,\n          Hl: t.vertLines.style,\n          Kl: this.tn.fn().Gl(),\n          Ul: this.tn.Ut().yt().Gl() || []\n        };\n      this.jt.tt(i), this.vt = !1;\n    }\n    return this.jt;\n  }\n}\nclass Bi {\n  constructor(t) {\n    this.bn = new Di(t);\n  }\n  Th() {\n    return this.bn;\n  }\n}\nconst Oi = {\n  Jl: 4,\n  Ql: 1e-4\n};\nfunction Ai(t, i) {\n  const n = 100 * (t - i) / i;\n  return i < 0 ? -n : n;\n}\nfunction Li(t, i) {\n  const n = Ai(t.lh(), i),\n    s = Ai(t.ah(), i);\n  return new pi(n, s);\n}\nfunction Ii(t, i) {\n  const n = 100 * (t - i) / i + 100;\n  return i < 0 ? -n : n;\n}\nfunction Ei(t, i) {\n  const n = Ii(t.lh(), i),\n    s = Ii(t.ah(), i);\n  return new pi(n, s);\n}\nfunction Vi(t, i) {\n  const n = Math.abs(t);\n  if (n < 1e-15) return 0;\n  const s = At(n + i.Ql) + i.Jl;\n  return t < 0 ? -s : s;\n}\nfunction zi(t, i) {\n  const n = Math.abs(t);\n  if (n < 1e-15) return 0;\n  const s = Math.pow(10, n - i.Jl) - i.Ql;\n  return t < 0 ? -s : s;\n}\nfunction Ni(t, i) {\n  if (null === t) return null;\n  const n = Vi(t.lh(), i),\n    s = Vi(t.ah(), i);\n  return new pi(n, s);\n}\nfunction Fi(t, i) {\n  if (null === t) return null;\n  const n = zi(t.lh(), i),\n    s = zi(t.ah(), i);\n  return new pi(n, s);\n}\nfunction Wi(t) {\n  if (null === t) return Oi;\n  const i = Math.abs(t.ah() - t.lh());\n  if (i >= 1 || i < 1e-15) return Oi;\n  const n = Math.ceil(Math.abs(Math.log10(i))),\n    s = Oi.Jl + n;\n  return {\n    Jl: s,\n    Ql: 1 / Math.pow(10, s)\n  };\n}\nclass ji {\n  constructor(t, i) {\n    if (this.ta = t, this.ia = i, function (t) {\n      if (t < 0) return !1;\n      for (let i = t; i > 1; i /= 10) if (i % 10 != 0) return !1;\n      return !0;\n    }(this.ta)) this.na = [2, 2.5, 2];else {\n      this.na = [];\n      for (let t = this.ta; 1 !== t;) {\n        if (t % 2 == 0) this.na.push(2), t /= 2;else {\n          if (t % 5 != 0) throw new Error(\"unexpected base\");\n          this.na.push(2, 2.5), t /= 5;\n        }\n        if (this.na.length > 100) throw new Error(\"something wrong with base\");\n      }\n    }\n  }\n  sa(t, i, n) {\n    const s = 0 === this.ta ? 0 : 1 / this.ta;\n    let e = Math.pow(10, Math.max(0, Math.ceil(At(t - i)))),\n      r = 0,\n      h = this.ia[0];\n    for (;;) {\n      const t = Ot(e, s, 1e-14) && e > s + 1e-14,\n        i = Ot(e, n * h, 1e-14),\n        l = Ot(e, 1, 1e-14);\n      if (!(t && i && l)) break;\n      e /= h, h = this.ia[++r % this.ia.length];\n    }\n    if (e <= s + 1e-14 && (e = s), e = Math.max(1, e), this.na.length > 0 && (l = e, a = 1, o = 1e-14, Math.abs(l - a) < o)) for (r = 0, h = this.na[0]; Ot(e, n * h, 1e-14) && e > s + 1e-14;) e /= h, h = this.na[++r % this.na.length];\n    var l, a, o;\n    return e;\n  }\n}\nclass $i {\n  constructor(t, i, n, s) {\n    this.ea = [], this.Vi = t, this.ta = i, this.ra = n, this.ha = s;\n  }\n  sa(t, i) {\n    if (t < i) throw new Error(\"high < low\");\n    const n = this.Vi.It(),\n      s = (t - i) * this.la() / n,\n      e = new ji(this.ta, [2, 2.5, 2]),\n      r = new ji(this.ta, [2, 2, 2.5]),\n      h = new ji(this.ta, [2.5, 2, 2]),\n      l = [];\n    return l.push(e.sa(t, i, s), r.sa(t, i, s), h.sa(t, i, s)), function (t) {\n      if (t.length < 1) throw Error(\"array is empty\");\n      let i = t[0];\n      for (let n = 1; n < t.length; ++n) t[n] < i && (i = t[n]);\n      return i;\n    }(l);\n  }\n  aa() {\n    const t = this.Vi,\n      i = t.Tt();\n    if (null === i) return void (this.ea = []);\n    const n = t.It(),\n      s = this.ra(n - 1, i),\n      e = this.ra(0, i),\n      r = this.Vi.F().entireTextOnly ? this.oa() / 2 : 0,\n      h = r,\n      l = n - 1 - r,\n      a = Math.max(s, e),\n      o = Math.min(s, e);\n    if (a === o) return void (this.ea = []);\n    let _ = this.sa(a, o),\n      u = a % _;\n    u += u < 0 ? _ : 0;\n    const c = a >= o ? 1 : -1;\n    let d = null,\n      f = 0;\n    for (let n = a - u; n > o; n -= _) {\n      const s = this.ha(n, i, !0);\n      null !== d && Math.abs(s - d) < this.la() || s < h || s > l || (f < this.ea.length ? (this.ea[f].ql = s, this.ea[f]._a = t.ua(n)) : this.ea.push({\n        ql: s,\n        _a: t.ua(n)\n      }), f++, d = s, t.ca() && (_ = this.sa(n * c, o)));\n    }\n    this.ea.length = f;\n  }\n  Gl() {\n    return this.ea;\n  }\n  oa() {\n    return this.Vi.T();\n  }\n  la() {\n    return Math.ceil(2.5 * this.oa());\n  }\n}\nfunction Hi(t) {\n  return t.slice().sort((t, i) => _(t.Zi()) - _(i.Zi()));\n}\nvar Ui;\n!function (t) {\n  t[t.Normal = 0] = \"Normal\", t[t.Logarithmic = 1] = \"Logarithmic\", t[t.Percentage = 2] = \"Percentage\", t[t.IndexedTo100 = 3] = \"IndexedTo100\";\n}(Ui || (Ui = {}));\nconst qi = new at(),\n  Yi = new lt(100, 1);\nclass Xi {\n  constructor(t, i, n, s) {\n    this.da = 0, this.fa = null, this.ph = null, this.pa = null, this.va = {\n      ma: !1,\n      ba: null\n    }, this.ga = 0, this.wa = 0, this.Ma = new M(), this.Sa = new M(), this.xa = [], this.ya = null, this.ka = null, this.Ca = null, this.Ta = null, this.Ol = Yi, this.Pa = Wi(null), this.Ra = t, this.un = i, this.Da = n, this.Ba = s, this.Oa = new $i(this, 100, this.Aa.bind(this), this.La.bind(this));\n  }\n  Vl() {\n    return this.Ra;\n  }\n  F() {\n    return this.un;\n  }\n  kh(t) {\n    if (S(this.un, t), this.zl(), void 0 !== t.mode && this.Ia({\n      lr: t.mode\n    }), void 0 !== t.scaleMargins) {\n      const i = o(t.scaleMargins.top),\n        n = o(t.scaleMargins.bottom);\n      if (i < 0 || i > 1) throw new Error(\"Invalid top margin - expect value between 0 and 1, given=\".concat(i));\n      if (n < 0 || n > 1 || i + n > 1) throw new Error(\"Invalid bottom margin - expect value between 0 and 1, given=\".concat(n));\n      if (i + n > 1) throw new Error(\"Invalid margins - sum of margins must be less than 1, given=\".concat(i + n));\n      this.Ea(), this.ka = null;\n    }\n  }\n  Va() {\n    return this.un.autoScale;\n  }\n  ca() {\n    return 1 === this.un.mode;\n  }\n  th() {\n    return 2 === this.un.mode;\n  }\n  za() {\n    return 3 === this.un.mode;\n  }\n  lr() {\n    return {\n      Fn: this.un.autoScale,\n      Na: this.un.invertScale,\n      lr: this.un.mode\n    };\n  }\n  Ia(t) {\n    const i = this.lr();\n    let n = null;\n    void 0 !== t.Fn && (this.un.autoScale = t.Fn), void 0 !== t.lr && (this.un.mode = t.lr, 2 !== t.lr && 3 !== t.lr || (this.un.autoScale = !0), this.va.ma = !1), 1 === i.lr && t.lr !== i.lr && (!function (t, i) {\n      if (null === t) return !1;\n      const n = zi(t.lh(), i),\n        s = zi(t.ah(), i);\n      return isFinite(n) && isFinite(s);\n    }(this.ph, this.Pa) ? this.un.autoScale = !0 : (n = Fi(this.ph, this.Pa), null !== n && this.Fa(n))), 1 === t.lr && t.lr !== i.lr && (n = Ni(this.ph, this.Pa), null !== n && this.Fa(n));\n    const s = i.lr !== this.un.mode;\n    s && (2 === i.lr || this.th()) && this.zl(), s && (3 === i.lr || this.za()) && this.zl(), void 0 !== t.Na && i.Na !== t.Na && (this.un.invertScale = t.Na, this.Wa()), this.Sa.m(i, this.lr());\n  }\n  ja() {\n    return this.Sa;\n  }\n  T() {\n    return this.Da.fontSize;\n  }\n  It() {\n    return this.da;\n  }\n  $a(t) {\n    this.da !== t && (this.da = t, this.Ea(), this.ka = null);\n  }\n  Ha() {\n    if (this.fa) return this.fa;\n    const t = this.It() - this.Ua() - this.qa();\n    return this.fa = t, t;\n  }\n  bh() {\n    return this.Ya(), this.ph;\n  }\n  Fa(t, i) {\n    const n = this.ph;\n    (i || null === n && null !== t || null !== n && !n.rh(t)) && (this.ka = null, this.ph = t);\n  }\n  Ni() {\n    return this.Ya(), 0 === this.da || !this.ph || this.ph.Ni();\n  }\n  Xa(t) {\n    return this.Na() ? t : this.It() - 1 - t;\n  }\n  Dt(t, i) {\n    return this.th() ? t = Ai(t, i) : this.za() && (t = Ii(t, i)), this.La(t, i);\n  }\n  $s(t, i, n) {\n    this.Ya();\n    const s = this.qa(),\n      e = _(this.bh()),\n      r = e.lh(),\n      h = e.ah(),\n      l = this.Ha() - 1,\n      a = this.Na(),\n      o = l / (h - r),\n      u = void 0 === n ? 0 : n.from,\n      c = void 0 === n ? t.length : n.to,\n      d = this.Za();\n    for (let n = u; n < c; n++) {\n      const e = t[n],\n        h = e.ut;\n      if (isNaN(h)) continue;\n      let l = h;\n      null !== d && (l = d(e.ut, i));\n      const _ = s + o * (l - r),\n        u = a ? _ : this.da - 1 - _;\n      e.et = u;\n    }\n  }\n  le(t, i, n) {\n    this.Ya();\n    const s = this.qa(),\n      e = _(this.bh()),\n      r = e.lh(),\n      h = e.ah(),\n      l = this.Ha() - 1,\n      a = this.Na(),\n      o = l / (h - r),\n      u = void 0 === n ? 0 : n.from,\n      c = void 0 === n ? t.length : n.to,\n      d = this.Za();\n    for (let n = u; n < c; n++) {\n      const e = t[n];\n      let h = e.oe,\n        l = e._e,\n        _ = e.ue,\n        u = e.ce;\n      null !== d && (h = d(e.oe, i), l = d(e._e, i), _ = d(e.ue, i), u = d(e.ce, i));\n      let c = s + o * (h - r),\n        f = a ? c : this.da - 1 - c;\n      e.re = f, c = s + o * (l - r), f = a ? c : this.da - 1 - c, e.ne = f, c = s + o * (_ - r), f = a ? c : this.da - 1 - c, e.se = f, c = s + o * (u - r), f = a ? c : this.da - 1 - c, e.he = f;\n    }\n  }\n  pn(t, i) {\n    const n = this.Aa(t, i);\n    return this.Ka(n, i);\n  }\n  Ka(t, i) {\n    let n = t;\n    return this.th() ? n = function (t, i) {\n      return i < 0 && (t = -t), t / 100 * i + i;\n    }(n, i) : this.za() && (n = function (t, i) {\n      return t -= 100, i < 0 && (t = -t), t / 100 * i + i;\n    }(n, i)), n;\n  }\n  Wl() {\n    return this.xa;\n  }\n  Ga() {\n    if (this.ya) return this.ya;\n    let t = [];\n    for (let i = 0; i < this.xa.length; i++) {\n      const n = this.xa[i];\n      null === n.Zi() && n.Ki(i + 1), t.push(n);\n    }\n    return t = Hi(t), this.ya = t, this.ya;\n  }\n  Ja(t) {\n    -1 === this.xa.indexOf(t) && (this.xa.push(t), this.zl(), this.Qa());\n  }\n  io(t) {\n    const i = this.xa.indexOf(t);\n    if (-1 === i) throw new Error(\"source is not attached to scale\");\n    this.xa.splice(i, 1), 0 === this.xa.length && (this.Ia({\n      Fn: !0\n    }), this.Fa(null)), this.zl(), this.Qa();\n  }\n  Tt() {\n    let t = null;\n    for (const i of this.xa) {\n      const n = i.Tt();\n      null !== n && (null === t || n.yl < t.yl) && (t = n);\n    }\n    return null === t ? null : t.Ot;\n  }\n  Na() {\n    return this.un.invertScale;\n  }\n  Gl() {\n    const t = null === this.Tt();\n    if (null !== this.ka && (t || this.ka.no === t)) return this.ka.Gl;\n    this.Oa.aa();\n    const i = this.Oa.Gl();\n    return this.ka = {\n      Gl: i,\n      no: t\n    }, this.Ma.m(), i;\n  }\n  so() {\n    return this.Ma;\n  }\n  eo(t) {\n    this.th() || this.za() || null === this.Ca && null === this.pa && (this.Ni() || (this.Ca = this.da - t, this.pa = _(this.bh()).hh()));\n  }\n  ro(t) {\n    if (this.th() || this.za()) return;\n    if (null === this.Ca) return;\n    this.Ia({\n      Fn: !1\n    }), (t = this.da - t) < 0 && (t = 0);\n    let i = (this.Ca + .2 * (this.da - 1)) / (t + .2 * (this.da - 1));\n    const n = _(this.pa).hh();\n    i = Math.max(i, .1), n._h(i), this.Fa(n);\n  }\n  ho() {\n    this.th() || this.za() || (this.Ca = null, this.pa = null);\n  }\n  lo(t) {\n    this.Va() || null === this.Ta && null === this.pa && (this.Ni() || (this.Ta = t, this.pa = _(this.bh()).hh()));\n  }\n  ao(t) {\n    if (this.Va()) return;\n    if (null === this.Ta) return;\n    const i = _(this.bh()).oh() / (this.Ha() - 1);\n    let n = t - this.Ta;\n    this.Na() && (n *= -1);\n    const s = n * i,\n      e = _(this.pa).hh();\n    e.uh(s), this.Fa(e, !0), this.ka = null;\n  }\n  oo() {\n    this.Va() || null !== this.Ta && (this.Ta = null, this.pa = null);\n  }\n  Bl() {\n    return this.Ol || this.zl(), this.Ol;\n  }\n  Fi(t, i) {\n    switch (this.un.mode) {\n      case 2:\n        return this.Bl().format(Ai(t, i));\n      case 3:\n        return this.Bl().format(Ii(t, i));\n      default:\n        return this.Sh(t);\n    }\n  }\n  ua(t) {\n    switch (this.un.mode) {\n      case 2:\n      case 3:\n        return this.Bl().format(t);\n      default:\n        return this.Sh(t);\n    }\n  }\n  _l(t) {\n    return this.Sh(t, _(this._o()).Bl());\n  }\n  ul(t, i) {\n    return t = Ai(t, i), qi.format(t);\n  }\n  uo() {\n    return this.xa;\n  }\n  co(t) {\n    this.va = {\n      ba: t,\n      ma: !1\n    };\n  }\n  Dn() {\n    this.xa.forEach(t => t.Dn());\n  }\n  zl() {\n    this.ka = null;\n    const t = this._o();\n    let i = 100;\n    null !== t && (i = Math.round(1 / t.Dl())), this.Ol = Yi, this.th() ? (this.Ol = qi, i = 100) : this.za() ? (this.Ol = new lt(100, 1), i = 100) : null !== t && (this.Ol = t.Bl()), this.Oa = new $i(this, i, this.Aa.bind(this), this.La.bind(this)), this.Oa.aa();\n  }\n  Qa() {\n    this.ya = null;\n  }\n  _o() {\n    return this.xa[0] || null;\n  }\n  Ua() {\n    return this.Na() ? this.un.scaleMargins.bottom * this.It() + this.wa : this.un.scaleMargins.top * this.It() + this.ga;\n  }\n  qa() {\n    return this.Na() ? this.un.scaleMargins.top * this.It() + this.ga : this.un.scaleMargins.bottom * this.It() + this.wa;\n  }\n  Ya() {\n    this.va.ma || (this.va.ma = !0, this.do());\n  }\n  Ea() {\n    this.fa = null;\n  }\n  La(t, i) {\n    if (this.Ya(), this.Ni()) return 0;\n    t = this.ca() && t ? Vi(t, this.Pa) : t;\n    const n = _(this.bh()),\n      s = this.qa() + (this.Ha() - 1) * (t - n.lh()) / n.oh();\n    return this.Xa(s);\n  }\n  Aa(t, i) {\n    if (this.Ya(), this.Ni()) return 0;\n    const n = this.Xa(t),\n      s = _(this.bh()),\n      e = s.lh() + s.oh() * ((n - this.qa()) / (this.Ha() - 1));\n    return this.ca() ? zi(e, this.Pa) : e;\n  }\n  Wa() {\n    this.ka = null, this.Oa.aa();\n  }\n  do() {\n    const t = this.va.ba;\n    if (null === t) return;\n    let i = null;\n    const n = this.uo();\n    let s = 0,\n      e = 0;\n    for (const r of n) {\n      if (!r.Ct()) continue;\n      const n = r.Tt();\n      if (null === n) continue;\n      const h = r.Pl(t.Ms(), t.ci());\n      let l = h && h.bh();\n      if (null !== l) {\n        switch (this.un.mode) {\n          case 1:\n            l = Ni(l, this.Pa);\n            break;\n          case 2:\n            l = Li(l, n.Ot);\n            break;\n          case 3:\n            l = Ei(l, n.Ot);\n        }\n        if (i = null === i ? l : i.Qn(_(l)), null !== h) {\n          const t = h.gh();\n          null !== t && (s = Math.max(s, t.above), e = Math.max(s, t.below));\n        }\n      }\n    }\n    if (s === this.ga && e === this.wa || (this.ga = s, this.wa = e, this.ka = null, this.Ea()), null !== i) {\n      if (i.lh() === i.ah()) {\n        const t = this._o(),\n          n = 5 * (null === t || this.th() || this.za() ? 1 : t.Dl());\n        this.ca() && (i = Fi(i, this.Pa)), i = new pi(i.lh() - n, i.ah() + n), this.ca() && (i = Ni(i, this.Pa));\n      }\n      if (this.ca()) {\n        const t = Fi(i, this.Pa),\n          n = Wi(t);\n        if (r = n, h = this.Pa, r.Jl !== h.Jl || r.Ql !== h.Ql) {\n          const s = null !== this.pa ? Fi(this.pa, this.Pa) : null;\n          this.Pa = n, i = Ni(t, n), null !== s && (this.pa = Ni(s, n));\n        }\n      }\n      this.Fa(i);\n    } else null === this.ph && (this.Fa(new pi(-.5, .5)), this.Pa = Wi(null));\n    var r, h;\n    this.va.ma = !0;\n  }\n  Za() {\n    return this.th() ? Ai : this.za() ? Ii : this.ca() ? t => Vi(t, this.Pa) : null;\n  }\n  Sh(t, i) {\n    return void 0 === this.Ba.priceFormatter ? (void 0 === i && (i = this.Bl()), i.format(t)) : this.Ba.priceFormatter(t);\n  }\n}\nclass Zi {\n  constructor(t, i) {\n    this.xa = [], this.fo = new Map(), this.da = 0, this.po = 0, this.vo = 1e3, this.ya = null, this.mo = new M(), this.bo = t, this.Hi = i, this.wo = new Bi(this);\n    const n = i.F();\n    this.Mo = this.So(\"left\", n.leftPriceScale), this.xo = this.So(\"right\", n.rightPriceScale), this.Mo.ja().l(this.yo.bind(this, this.Mo), this), this.xo.ja().l(this.yo.bind(this, this.xo), this), this.ko(n);\n  }\n  ko(t) {\n    if (t.leftPriceScale && this.Mo.kh(t.leftPriceScale), t.rightPriceScale && this.xo.kh(t.rightPriceScale), t.localization && (this.Mo.zl(), this.xo.zl()), t.overlayPriceScales) {\n      const i = Array.from(this.fo.values());\n      for (const n of i) {\n        const i = _(n[0].Bt());\n        i.kh(t.overlayPriceScales), t.localization && i.zl();\n      }\n    }\n  }\n  Co(t) {\n    switch (t) {\n      case \"left\":\n        return this.Mo;\n      case \"right\":\n        return this.xo;\n    }\n    return this.fo.has(t) ? o(this.fo.get(t))[0].Bt() : null;\n  }\n  M() {\n    this.Ut().To().v(this), this.Mo.ja().v(this), this.xo.ja().v(this), this.xa.forEach(t => {\n      t.M && t.M();\n    }), this.mo.m();\n  }\n  Po() {\n    return this.vo;\n  }\n  Ro(t) {\n    this.vo = t;\n  }\n  Ut() {\n    return this.Hi;\n  }\n  $i() {\n    return this.po;\n  }\n  It() {\n    return this.da;\n  }\n  Do(t) {\n    this.po = t, this.Bo();\n  }\n  $a(t) {\n    this.da = t, this.Mo.$a(t), this.xo.$a(t), this.xa.forEach(i => {\n      if (this.Ge(i)) {\n        const n = i.Bt();\n        null !== n && n.$a(t);\n      }\n    }), this.Bo();\n  }\n  Wl() {\n    return this.xa;\n  }\n  Ge(t) {\n    const i = t.Bt();\n    return null === i || this.Mo !== i && this.xo !== i;\n  }\n  Ja(t, i, n) {\n    const s = void 0 !== n ? n : this.Ao().Oo + 1;\n    this.Lo(t, i, s);\n  }\n  io(t) {\n    const i = this.xa.indexOf(t);\n    a(-1 !== i, \"removeDataSource: invalid data source\"), this.xa.splice(i, 1);\n    const n = _(t.Bt()).Vl();\n    if (this.fo.has(n)) {\n      const i = o(this.fo.get(n)),\n        s = i.indexOf(t);\n      -1 !== s && (i.splice(s, 1), 0 === i.length && this.fo.delete(n));\n    }\n    const s = t.Bt();\n    s && s.Wl().indexOf(t) >= 0 && s.io(t), null !== s && (s.Qa(), this.Io(s)), this.ya = null;\n  }\n  Qe(t) {\n    return t === this.Mo ? \"left\" : t === this.xo ? \"right\" : \"overlay\";\n  }\n  Eo() {\n    return this.Mo;\n  }\n  Vo() {\n    return this.xo;\n  }\n  zo(t, i) {\n    t.eo(i);\n  }\n  No(t, i) {\n    t.ro(i), this.Bo();\n  }\n  Fo(t) {\n    t.ho();\n  }\n  Wo(t, i) {\n    t.lo(i);\n  }\n  jo(t, i) {\n    t.ao(i), this.Bo();\n  }\n  $o(t) {\n    t.oo();\n  }\n  Bo() {\n    this.xa.forEach(t => {\n      t.Dn();\n    });\n  }\n  fn() {\n    let t = null;\n    return this.Hi.F().rightPriceScale.visible && 0 !== this.xo.Wl().length ? t = this.xo : this.Hi.F().leftPriceScale.visible && 0 !== this.Mo.Wl().length ? t = this.Mo : 0 !== this.xa.length && (t = this.xa[0].Bt()), null === t && (t = this.xo), t;\n  }\n  Je() {\n    let t = null;\n    return this.Hi.F().rightPriceScale.visible ? t = this.xo : this.Hi.F().leftPriceScale.visible && (t = this.Mo), t;\n  }\n  Io(t) {\n    null !== t && t.Va() && this.Ho(t);\n  }\n  Uo(t) {\n    const i = this.bo.zs();\n    t.Ia({\n      Fn: !0\n    }), null !== i && t.co(i), this.Bo();\n  }\n  qo() {\n    this.Ho(this.Mo), this.Ho(this.xo);\n  }\n  Yo() {\n    this.Io(this.Mo), this.Io(this.xo), this.xa.forEach(t => {\n      this.Ge(t) && this.Io(t.Bt());\n    }), this.Bo(), this.Hi.Ch();\n  }\n  Ga() {\n    return null === this.ya && (this.ya = Hi(this.xa)), this.ya;\n  }\n  Xo() {\n    return this.mo;\n  }\n  Zo() {\n    return this.wo;\n  }\n  Ho(t) {\n    const i = t.uo();\n    if (i && i.length > 0 && !this.bo.Ni()) {\n      const i = this.bo.zs();\n      null !== i && t.co(i);\n    }\n    t.Dn();\n  }\n  Ao() {\n    const t = this.Ga();\n    if (0 === t.length) return {\n      Ko: 0,\n      Oo: 0\n    };\n    let i = 0,\n      n = 0;\n    for (let s = 0; s < t.length; s++) {\n      const e = t[s].Zi();\n      null !== e && (e < i && (i = e), e > n && (n = e));\n    }\n    return {\n      Ko: i,\n      Oo: n\n    };\n  }\n  Lo(t, i, n) {\n    let s = this.Co(i);\n    if (null === s && (s = this.So(i, this.Hi.F().overlayPriceScales)), this.xa.push(t), !st(i)) {\n      const n = this.fo.get(i) || [];\n      n.push(t), this.fo.set(i, n);\n    }\n    s.Ja(t), t.Gi(s), t.Ki(n), this.Io(s), this.ya = null;\n  }\n  yo(t, i, n) {\n    i.lr !== n.lr && this.Ho(t);\n  }\n  So(t, i) {\n    const n = Object.assign({\n        visible: !0,\n        autoScale: !0\n      }, T(i)),\n      s = new Xi(t, n, this.Hi.F().layout, this.Hi.F().localization);\n    return s.$a(this.It()), s;\n  }\n}\nconst Ki = t => t.getUTCFullYear();\nfunction Gi(t, i, n) {\n  return i.replace(/yyyy/g, (t => ht(Ki(t), 4))(t)).replace(/yy/g, (t => ht(Ki(t) % 100, 2))(t)).replace(/MMMM/g, ((t, i) => new Date(t.getUTCFullYear(), t.getUTCMonth(), 1).toLocaleString(i, {\n    month: \"long\"\n  }))(t, n)).replace(/MMM/g, ((t, i) => new Date(t.getUTCFullYear(), t.getUTCMonth(), 1).toLocaleString(i, {\n    month: \"short\"\n  }))(t, n)).replace(/MM/g, (t => ht((t => t.getUTCMonth() + 1)(t), 2))(t)).replace(/dd/g, (t => ht((t => t.getUTCDate())(t), 2))(t));\n}\nclass Ji {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"yyyy-MM-dd\";\n    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n    this.Go = t, this.Jo = i;\n  }\n  Qo(t) {\n    return Gi(t, this.Go, this.Jo);\n  }\n}\nclass Qi {\n  constructor(t) {\n    this.t_ = t || \"%h:%m:%s\";\n  }\n  Qo(t) {\n    return this.t_.replace(\"%h\", ht(t.getUTCHours(), 2)).replace(\"%m\", ht(t.getUTCMinutes(), 2)).replace(\"%s\", ht(t.getUTCSeconds(), 2));\n  }\n}\nconst tn = {\n  i_: \"yyyy-MM-dd\",\n  n_: \"%h:%m:%s\",\n  s_: \" \",\n  e_: \"default\"\n};\nclass nn {\n  constructor() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const i = Object.assign(Object.assign({}, tn), t);\n    this.r_ = new Ji(i.i_, i.e_), this.h_ = new Qi(i.n_), this.l_ = i.s_;\n  }\n  Qo(t) {\n    return \"\".concat(this.r_.Qo(t)).concat(this.l_).concat(this.h_.Qo(t));\n  }\n}\nclass sn {\n  constructor(t) {\n    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n    this.Le = 0, this.Ie = 1, this.Ee = 1, this.ze = new Map(), this.Ve = new Map(), this.a_ = t, this.Ne = i;\n  }\n  Qo(t) {\n    const i = t._t,\n      n = void 0 === i.o_ ? new Date(1e3 * i.__).getTime() : new Date(Date.UTC(i.o_.year, i.o_.month - 1, i.o_.day)).getTime(),\n      s = this.ze.get(n);\n    if (void 0 !== s) return s.u_;\n    if (this.Le === this.Ne) {\n      const t = this.Ve.get(this.Ee);\n      this.Ve.delete(this.Ee), this.ze.delete(o(t)), this.Ee++, this.Le--;\n    }\n    const e = this.a_(t);\n    return this.ze.set(n, {\n      u_: e,\n      $e: this.Ie\n    }), this.Ve.set(this.Ie, n), this.Le++, this.Ie++, e;\n  }\n}\nclass en {\n  constructor(t, i) {\n    a(t <= i, \"right should be >= left\"), this.c_ = t, this.d_ = i;\n  }\n  Ms() {\n    return this.c_;\n  }\n  ci() {\n    return this.d_;\n  }\n  f_() {\n    return this.d_ - this.c_ + 1;\n  }\n  Ir(t) {\n    return this.c_ <= t && t <= this.d_;\n  }\n  rh(t) {\n    return this.c_ === t.Ms() && this.d_ === t.ci();\n  }\n}\nfunction rn(t, i) {\n  return null === t || null === i ? t === i : t.rh(i);\n}\nclass hn {\n  constructor() {\n    this.p_ = new Map(), this.ze = null;\n  }\n  v_(t, i) {\n    this.m_(i), this.ze = null;\n    for (let n = i; n < t.length; ++n) {\n      const i = t[n];\n      let s = this.p_.get(i.b_);\n      void 0 === s && (s = [], this.p_.set(i.b_, s)), s.push({\n        Ys: n,\n        _t: i._t,\n        g_: i.b_,\n        w_: i.w_\n      });\n    }\n  }\n  M_(t, i) {\n    const n = Math.ceil(i / t);\n    return null !== this.ze && this.ze.S_ === n || (this.ze = {\n      Gl: this.x_(n),\n      S_: n\n    }), this.ze.Gl;\n  }\n  m_(t) {\n    if (0 === t) return void this.p_.clear();\n    const i = [];\n    this.p_.forEach((n, s) => {\n      t <= n[0].Ys ? i.push(s) : n.splice(wt(n, t, i => i.Ys < t), 1 / 0);\n    });\n    for (const t of i) this.p_.delete(t);\n  }\n  x_(t) {\n    let i = [];\n    for (const n of Array.from(this.p_.keys()).sort((t, i) => i - t)) {\n      if (!this.p_.get(n)) continue;\n      const s = i;\n      i = [];\n      const e = s.length;\n      let r = 0;\n      const h = o(this.p_.get(n)),\n        l = h.length;\n      let a = 1 / 0,\n        _ = -1 / 0;\n      for (let n = 0; n < l; n++) {\n        const l = h[n],\n          o = l.Ys;\n        for (; r < e;) {\n          const t = s[r],\n            n = t.Ys;\n          if (!(n < o)) {\n            a = n;\n            break;\n          }\n          r++, i.push(t), _ = n, a = 1 / 0;\n        }\n        a - o >= t && o - _ >= t && (i.push(l), _ = o);\n      }\n      for (; r < e; r++) i.push(s[r]);\n    }\n    return i;\n  }\n}\nclass ln {\n  constructor(t) {\n    this.y_ = t;\n  }\n  k_() {\n    return null === this.y_ ? null : new en(Math.floor(this.y_.Ms()), Math.ceil(this.y_.ci()));\n  }\n  C_() {\n    return this.y_;\n  }\n  static T_() {\n    return new ln(null);\n  }\n}\nvar an, on, _n, un, cn;\n!function (t) {\n  t[t.Year = 0] = \"Year\", t[t.Month = 1] = \"Month\", t[t.DayOfMonth = 2] = \"DayOfMonth\", t[t.Time = 3] = \"Time\", t[t.TimeWithSeconds = 4] = \"TimeWithSeconds\";\n}(an || (an = {}));\nclass dn {\n  constructor(t, i, n) {\n    this.po = 0, this.P_ = null, this.R_ = [], this.Ta = null, this.Ca = null, this.D_ = new hn(), this.B_ = new Map(), this.O_ = ln.T_(), this.A_ = !0, this.L_ = new M(), this.I_ = new M(), this.E_ = new M(), this.V_ = null, this.z_ = null, this.N_ = [], this.un = i, this.Ba = n, this.F_ = i.rightOffset, this.W_ = i.barSpacing, this.Hi = t, this.j_();\n  }\n  F() {\n    return this.un;\n  }\n  H_(t) {\n    S(this.Ba, t), this.U_(), this.j_();\n  }\n  kh(t, i) {\n    var n;\n    S(this.un, t), this.un.fixLeftEdge && this.q_(), this.un.fixRightEdge && this.Y_(), void 0 !== t.barSpacing && this.Hi.Kn(t.barSpacing), void 0 !== t.rightOffset && this.Hi.Gn(t.rightOffset), void 0 !== t.minBarSpacing && this.Hi.Kn(null !== (n = t.barSpacing) && void 0 !== n ? n : this.W_), this.U_(), this.j_(), this.E_.m();\n  }\n  vn(t) {\n    var i, n;\n    return null !== (n = null === (i = this.R_[t]) || void 0 === i ? void 0 : i._t) && void 0 !== n ? n : null;\n  }\n  Ui(t) {\n    var i;\n    return null !== (i = this.R_[t]) && void 0 !== i ? i : null;\n  }\n  Nl(t, i) {\n    if (this.R_.length < 1) return null;\n    if (t.__ > this.R_[this.R_.length - 1]._t.__) return i ? this.R_.length - 1 : null;\n    const n = wt(this.R_, t.__, (t, i) => t._t.__ < i);\n    return t.__ < this.R_[n]._t.__ ? i ? n : null : n;\n  }\n  Ni() {\n    return 0 === this.po || 0 === this.R_.length || null === this.P_;\n  }\n  zs() {\n    return this.X_(), this.O_.k_();\n  }\n  Z_() {\n    return this.X_(), this.O_.C_();\n  }\n  K_() {\n    const t = this.zs();\n    if (null === t) return null;\n    const i = {\n      from: t.Ms(),\n      to: t.ci()\n    };\n    return this.G_(i);\n  }\n  G_(t) {\n    const i = Math.round(t.from),\n      n = Math.round(t.to),\n      s = _(this.J_()),\n      e = _(this.Q_());\n    return {\n      from: _(this.vn(Math.max(s, i))),\n      to: _(this.vn(Math.min(e, n)))\n    };\n  }\n  tu(t) {\n    return {\n      from: _(this.Nl(t.from, !0)),\n      to: _(this.Nl(t.to, !0))\n    };\n  }\n  $i() {\n    return this.po;\n  }\n  Do(t) {\n    if (!isFinite(t) || t <= 0) return;\n    if (this.po === t) return;\n    const i = this.Z_(),\n      n = this.po;\n    if (this.po = t, this.A_ = !0, this.un.lockVisibleTimeRangeOnResize && 0 !== n) {\n      const i = this.W_ * t / n;\n      this.W_ = i;\n    }\n    if (this.un.fixLeftEdge && null !== i && i.Ms() <= 0) {\n      const i = n - t;\n      this.F_ -= Math.round(i / this.W_) + 1, this.A_ = !0;\n    }\n    this.iu(), this.nu();\n  }\n  Et(t) {\n    if (this.Ni() || !y(t)) return 0;\n    const i = this.su() + this.F_ - t;\n    return this.po - (i + .5) * this.W_ - 1;\n  }\n  js(t, i) {\n    const n = this.su(),\n      s = void 0 === i ? 0 : i.from,\n      e = void 0 === i ? t.length : i.to;\n    for (let i = s; i < e; i++) {\n      const s = t[i]._t,\n        e = n + this.F_ - s,\n        r = this.po - (e + .5) * this.W_ - 1;\n      t[i].st = r;\n    }\n  }\n  eu(t) {\n    return Math.ceil(this.ru(t));\n  }\n  Gn(t) {\n    this.A_ = !0, this.F_ = t, this.nu(), this.Hi.hu(), this.Hi.Ch();\n  }\n  Ks() {\n    return this.W_;\n  }\n  Kn(t) {\n    this.lu(t), this.nu(), this.Hi.hu(), this.Hi.Ch();\n  }\n  au() {\n    return this.F_;\n  }\n  Gl() {\n    if (this.Ni()) return null;\n    if (null !== this.z_) return this.z_;\n    const t = this.W_,\n      i = 5 * (this.Hi.F().layout.fontSize + 4),\n      n = Math.round(i / t),\n      s = _(this.zs()),\n      e = Math.max(s.Ms(), s.Ms() - n),\n      r = Math.max(s.ci(), s.ci() - n),\n      h = this.D_.M_(t, i),\n      l = this.J_() + n,\n      a = this.Q_() - n,\n      o = this.ou(),\n      u = this.un.fixLeftEdge || o,\n      c = this.un.fixRightEdge || o;\n    let d = 0;\n    for (const t of h) {\n      if (!(e <= t.Ys && t.Ys <= r)) continue;\n      let n;\n      d < this.N_.length ? (n = this.N_[d], n.ql = this.Et(t.Ys), n._a = this._u(t), n.g_ = t.g_) : (n = {\n        uu: !1,\n        ql: this.Et(t.Ys),\n        _a: this._u(t),\n        g_: t.g_\n      }, this.N_.push(n)), this.W_ > i / 2 && !o ? n.uu = !1 : n.uu = u && t.Ys <= l || c && t.Ys >= a, d++;\n    }\n    return this.N_.length = d, this.z_ = this.N_, this.N_;\n  }\n  cu() {\n    this.A_ = !0, this.Kn(this.un.barSpacing), this.Gn(this.un.rightOffset);\n  }\n  du(t) {\n    this.A_ = !0, this.P_ = t, this.nu(), this.q_();\n  }\n  fu(t, i) {\n    const n = this.ru(t),\n      s = this.Ks(),\n      e = s + i * (s / 10);\n    this.Kn(e), this.un.rightBarStaysOnScroll || this.Gn(this.au() + (n - this.ru(t)));\n  }\n  eo(t) {\n    this.Ta && this.oo(), null === this.Ca && null === this.V_ && (this.Ni() || (this.Ca = t, this.pu()));\n  }\n  ro(t) {\n    if (null === this.V_) return;\n    const i = Bt(this.po - t, 0, this.po),\n      n = Bt(this.po - _(this.Ca), 0, this.po);\n    0 !== i && 0 !== n && this.Kn(this.V_.Ks * i / n);\n  }\n  ho() {\n    null !== this.Ca && (this.Ca = null, this.vu());\n  }\n  lo(t) {\n    null === this.Ta && null === this.V_ && (this.Ni() || (this.Ta = t, this.pu()));\n  }\n  ao(t) {\n    if (null === this.Ta) return;\n    const i = (this.Ta - t) / this.Ks();\n    this.F_ = _(this.V_).au + i, this.A_ = !0, this.nu();\n  }\n  oo() {\n    null !== this.Ta && (this.Ta = null, this.vu());\n  }\n  mu() {\n    this.bu(this.un.rightOffset);\n  }\n  bu(t) {\n    let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;\n    if (!isFinite(t)) throw new RangeError(\"offset is required and must be finite number\");\n    if (!isFinite(i) || i <= 0) throw new RangeError(\"animationDuration (optional) must be finite positive number\");\n    const n = this.F_,\n      s = performance.now();\n    this.Hi.Yn({\n      gu: t => (t - s) / i >= 1,\n      wu: e => {\n        const r = (e - s) / i;\n        return r >= 1 ? t : n + (t - n) * r;\n      }\n    });\n  }\n  gt(t, i) {\n    this.A_ = !0, this.R_ = t, this.D_.v_(t, i), this.nu();\n  }\n  Mu() {\n    return this.L_;\n  }\n  Su() {\n    return this.I_;\n  }\n  xu() {\n    return this.E_;\n  }\n  su() {\n    return this.P_ || 0;\n  }\n  yu(t) {\n    const i = t.f_();\n    this.lu(this.po / i), this.F_ = t.ci() - this.su(), this.nu(), this.A_ = !0, this.Hi.hu(), this.Hi.Ch();\n  }\n  ku() {\n    const t = this.J_(),\n      i = this.Q_();\n    null !== t && null !== i && this.yu(new en(t, i + this.un.rightOffset));\n  }\n  Cu(t) {\n    const i = new en(t.from, t.to);\n    this.yu(i);\n  }\n  qi(t) {\n    return void 0 !== this.Ba.timeFormatter ? this.Ba.timeFormatter(t.w_) : this.Tu.Qo(new Date(1e3 * t._t.__));\n  }\n  ou() {\n    const {\n      handleScroll: t,\n      handleScale: i\n    } = this.Hi.F();\n    return !(t.horzTouchDrag || t.mouseWheel || t.pressedMouseMove || t.vertTouchDrag || i.axisDoubleClickReset.time || i.axisPressedMouseMove.time || i.mouseWheel || i.pinch);\n  }\n  J_() {\n    return 0 === this.R_.length ? null : 0;\n  }\n  Q_() {\n    return 0 === this.R_.length ? null : this.R_.length - 1;\n  }\n  Pu(t) {\n    return (this.po - 1 - t) / this.W_;\n  }\n  ru(t) {\n    const i = this.Pu(t),\n      n = this.su() + this.F_ - i;\n    return Math.round(1e6 * n) / 1e6;\n  }\n  lu(t) {\n    const i = this.W_;\n    this.W_ = t, this.iu(), i !== this.W_ && (this.A_ = !0, this.Ru());\n  }\n  X_() {\n    if (!this.A_) return;\n    if (this.A_ = !1, this.Ni()) return void this.Du(ln.T_());\n    const t = this.su(),\n      i = this.po / this.W_,\n      n = this.F_ + t,\n      s = new en(n - i + 1, n);\n    this.Du(new ln(s));\n  }\n  iu() {\n    const t = this.Bu();\n    if (this.W_ < t && (this.W_ = t, this.A_ = !0), 0 !== this.po) {\n      const t = .5 * this.po;\n      this.W_ > t && (this.W_ = t, this.A_ = !0);\n    }\n  }\n  Bu() {\n    return this.un.fixLeftEdge && this.un.fixRightEdge && 0 !== this.R_.length ? this.po / this.R_.length : this.un.minBarSpacing;\n  }\n  nu() {\n    const t = this.Ou();\n    this.F_ > t && (this.F_ = t, this.A_ = !0);\n    const i = this.Au();\n    null !== i && this.F_ < i && (this.F_ = i, this.A_ = !0);\n  }\n  Au() {\n    const t = this.J_(),\n      i = this.P_;\n    if (null === t || null === i) return null;\n    return t - i - 1 + (this.un.fixLeftEdge ? this.po / this.W_ : Math.min(2, this.R_.length));\n  }\n  Ou() {\n    return this.un.fixRightEdge ? 0 : this.po / this.W_ - Math.min(2, this.R_.length);\n  }\n  pu() {\n    this.V_ = {\n      Ks: this.Ks(),\n      au: this.au()\n    };\n  }\n  vu() {\n    this.V_ = null;\n  }\n  _u(t) {\n    let i = this.B_.get(t.g_);\n    return void 0 === i && (i = new sn(t => this.Lu(t)), this.B_.set(t.g_, i)), i.Qo(t);\n  }\n  Lu(t) {\n    const i = function (t, i, n) {\n      switch (t) {\n        case 0:\n        case 10:\n          return i ? n ? 4 : 3 : 2;\n        case 20:\n        case 21:\n        case 22:\n        case 30:\n        case 31:\n        case 32:\n        case 33:\n          return i ? 3 : 2;\n        case 50:\n          return 2;\n        case 60:\n          return 1;\n        case 70:\n          return 0;\n      }\n    }(t.g_, this.un.timeVisible, this.un.secondsVisible);\n    if (void 0 !== this.un.tickMarkFormatter) {\n      const n = this.un.tickMarkFormatter(t.w_, i, this.Ba.locale);\n      if (null !== n) return n;\n    }\n    return function (t, i, n) {\n      const s = {};\n      switch (i) {\n        case 0:\n          s.year = \"numeric\";\n          break;\n        case 1:\n          s.month = \"short\";\n          break;\n        case 2:\n          s.day = \"numeric\";\n          break;\n        case 3:\n          s.hour12 = !1, s.hour = \"2-digit\", s.minute = \"2-digit\";\n          break;\n        case 4:\n          s.hour12 = !1, s.hour = \"2-digit\", s.minute = \"2-digit\", s.second = \"2-digit\";\n      }\n      const e = void 0 === t.o_ ? new Date(1e3 * t.__) : new Date(Date.UTC(t.o_.year, t.o_.month - 1, t.o_.day));\n      return new Date(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()).toLocaleString(n, s);\n    }(t._t, i, this.Ba.locale);\n  }\n  Du(t) {\n    const i = this.O_;\n    this.O_ = t, rn(i.k_(), this.O_.k_()) || this.L_.m(), rn(i.C_(), this.O_.C_()) || this.I_.m(), this.Ru();\n  }\n  Ru() {\n    this.z_ = null;\n  }\n  U_() {\n    this.Ru(), this.B_.clear();\n  }\n  j_() {\n    const t = this.Ba.dateFormat;\n    this.un.timeVisible ? this.Tu = new nn({\n      i_: t,\n      n_: this.un.secondsVisible ? \"%h:%m:%s\" : \"%h:%m\",\n      s_: \"   \",\n      e_: this.Ba.locale\n    }) : this.Tu = new Ji(t, this.Ba.locale);\n  }\n  q_() {\n    if (!this.un.fixLeftEdge) return;\n    const t = this.J_();\n    if (null === t) return;\n    const i = this.zs();\n    if (null === i) return;\n    const n = i.Ms() - t;\n    if (n < 0) {\n      const t = this.F_ - n - 1;\n      this.Gn(t);\n    }\n    this.iu();\n  }\n  Y_() {\n    this.nu(), this.iu();\n  }\n}\nclass fn extends L {\n  constructor(t) {\n    super(), this.Iu = new Map(), this.Vt = t;\n  }\n  Z(t) {}\n  G(t) {\n    if (!this.Vt.Ct) return;\n    const {\n      context: i,\n      mediaSize: n\n    } = t;\n    let s = 0;\n    for (const t of this.Vt.Eu) {\n      if (0 === t.Gt.length) continue;\n      i.font = t.P;\n      const e = this.Vu(i, t.Gt);\n      e > n.width ? t.fu = n.width / e : t.fu = 1, s += t.zu * t.fu;\n    }\n    let e = 0;\n    switch (this.Vt.Nu) {\n      case \"top\":\n        e = 0;\n        break;\n      case \"center\":\n        e = Math.max((n.height - s) / 2, 0);\n        break;\n      case \"bottom\":\n        e = Math.max(n.height - s, 0);\n    }\n    i.fillStyle = this.Vt.D;\n    for (const t of this.Vt.Eu) {\n      i.save();\n      let s = 0;\n      switch (this.Vt.Fu) {\n        case \"left\":\n          i.textAlign = \"left\", s = t.zu / 2;\n          break;\n        case \"center\":\n          i.textAlign = \"center\", s = n.width / 2;\n          break;\n        case \"right\":\n          i.textAlign = \"right\", s = n.width - 1 - t.zu / 2;\n      }\n      i.translate(s, e), i.textBaseline = \"top\", i.font = t.P, i.scale(t.fu, t.fu), i.fillText(t.Gt, 0, t.Wu), i.restore(), e += t.zu * t.fu;\n    }\n  }\n  Vu(t, i) {\n    const n = this.ju(t.font);\n    let s = n.get(i);\n    return void 0 === s && (s = t.measureText(i).width, n.set(i, s)), s;\n  }\n  ju(t) {\n    let i = this.Iu.get(t);\n    return void 0 === i && (i = new Map(), this.Iu.set(t, i)), i;\n  }\n}\nclass pn {\n  constructor(t) {\n    this.vt = !0, this.Wt = {\n      Ct: !1,\n      D: \"\",\n      Eu: [],\n      Nu: \"center\",\n      Fu: \"center\"\n    }, this.jt = new fn(this.Wt), this.$t = t;\n  }\n  gt() {\n    this.vt = !0;\n  }\n  Mt() {\n    return this.vt && (this.St(), this.vt = !1), this.jt;\n  }\n  St() {\n    const t = this.$t.F(),\n      i = this.Wt;\n    i.Ct = t.visible, i.Ct && (i.D = t.color, i.Fu = t.horzAlign, i.Nu = t.vertAlign, i.Eu = [{\n      Gt: t.text,\n      P: B(t.fontSize, t.fontFamily, t.fontStyle),\n      zu: 1.2 * t.fontSize,\n      Wu: 0,\n      fu: 0\n    }]);\n  }\n}\nclass vn extends tt {\n  constructor(t, i) {\n    super(), this.un = i, this.bn = new pn(this);\n  }\n  Pn() {\n    return [];\n  }\n  Tn() {\n    return [this.bn];\n  }\n  F() {\n    return this.un;\n  }\n  Dn() {\n    this.bn.gt();\n  }\n}\n!function (t) {\n  t[t.OnTouchEnd = 0] = \"OnTouchEnd\", t[t.OnNextTap = 1] = \"OnNextTap\";\n}(on || (on = {}));\nclass mn {\n  constructor(t, i) {\n    this.$u = [], this.Hu = [], this.po = 0, this.Uu = null, this.qu = new M(), this.Yu = new M(), this.Xu = null, this.Zu = t, this.un = i, this.Ku = new O(this), this.bo = new dn(this, i.timeScale, this.un.localization), this.bt = new nt(this, i.crosshair), this.Gu = new Pi(i.crosshair), this.Ju = new vn(this, i.watermark), this.Qu(), this.$u[0].Ro(2e3), this.tc = this.ic(0), this.nc = this.ic(1);\n  }\n  dl() {\n    this.sc(et.ss());\n  }\n  Ch() {\n    this.sc(et.ns());\n  }\n  Cl() {\n    this.sc(new et(1));\n  }\n  fl(t) {\n    const i = this.ec(t);\n    this.sc(i);\n  }\n  rc() {\n    return this.Uu;\n  }\n  hc(t) {\n    const i = this.Uu;\n    this.Uu = t, null !== i && this.fl(i.lc), null !== t && this.fl(t.lc);\n  }\n  F() {\n    return this.un;\n  }\n  kh(t) {\n    S(this.un, t), this.$u.forEach(i => i.ko(t)), void 0 !== t.timeScale && this.bo.kh(t.timeScale), void 0 !== t.localization && this.bo.H_(t.localization), (t.leftPriceScale || t.rightPriceScale) && this.qu.m(), this.tc = this.ic(0), this.nc = this.ic(1), this.dl();\n  }\n  ac(t, i) {\n    if (\"left\" === t) return void this.kh({\n      leftPriceScale: i\n    });\n    if (\"right\" === t) return void this.kh({\n      rightPriceScale: i\n    });\n    const n = this.oc(t);\n    null !== n && (n.Bt.kh(i), this.qu.m());\n  }\n  oc(t) {\n    for (const i of this.$u) {\n      const n = i.Co(t);\n      if (null !== n) return {\n        Ht: i,\n        Bt: n\n      };\n    }\n    return null;\n  }\n  yt() {\n    return this.bo;\n  }\n  _c() {\n    return this.$u;\n  }\n  uc() {\n    return this.Ju;\n  }\n  cc() {\n    return this.bt;\n  }\n  dc() {\n    return this.Yu;\n  }\n  fc(t, i) {\n    t.$a(i), this.hu();\n  }\n  Do(t) {\n    this.po = t, this.bo.Do(this.po), this.$u.forEach(i => i.Do(t)), this.hu();\n  }\n  Qu(t) {\n    const i = new Zi(this.bo, this);\n    void 0 !== t ? this.$u.splice(t, 0, i) : this.$u.push(i);\n    const n = void 0 === t ? this.$u.length - 1 : t,\n      s = et.ss();\n    return s.zn(n, {\n      Nn: 0,\n      Fn: !0\n    }), this.sc(s), i;\n  }\n  zo(t, i, n) {\n    t.zo(i, n);\n  }\n  No(t, i, n) {\n    t.No(i, n), this.pl(), this.sc(this.vc(t, 2));\n  }\n  Fo(t, i) {\n    t.Fo(i), this.sc(this.vc(t, 2));\n  }\n  Wo(t, i, n) {\n    i.Va() || t.Wo(i, n);\n  }\n  jo(t, i, n) {\n    i.Va() || (t.jo(i, n), this.pl(), this.sc(this.vc(t, 2)));\n  }\n  $o(t, i) {\n    i.Va() || (t.$o(i), this.sc(this.vc(t, 2)));\n  }\n  Uo(t, i) {\n    t.Uo(i), this.sc(this.vc(t, 2));\n  }\n  mc(t) {\n    this.bo.eo(t);\n  }\n  bc(t, i) {\n    const n = this.yt();\n    if (n.Ni() || 0 === i) return;\n    const s = n.$i();\n    t = Math.max(1, Math.min(t, s)), n.fu(t, i), this.hu();\n  }\n  gc(t) {\n    this.wc(0), this.Mc(t), this.Sc();\n  }\n  xc(t) {\n    this.bo.ro(t), this.hu();\n  }\n  yc() {\n    this.bo.ho(), this.Ch();\n  }\n  wc(t) {\n    this.bo.lo(t);\n  }\n  Mc(t) {\n    this.bo.ao(t), this.hu();\n  }\n  Sc() {\n    this.bo.oo(), this.Ch();\n  }\n  wt() {\n    return this.Hu;\n  }\n  kc(t, i, n, s) {\n    this.bt.gn(t, i);\n    let e = NaN,\n      r = this.bo.eu(t);\n    const h = this.bo.zs();\n    null !== h && (r = Math.min(Math.max(h.Ms(), r), h.ci()));\n    const l = s.fn(),\n      a = l.Tt();\n    null !== a && (e = l.pn(i, a)), e = this.Gu.Fl(e, r, s), this.bt.xn(r, e, s), this.Cl(), this.Yu.m(this.bt.xt(), {\n      x: t,\n      y: i\n    }, n);\n  }\n  Cc() {\n    this.cc().kn(), this.Cl(), this.Yu.m(null, null, null);\n  }\n  pl() {\n    const t = this.bt.Ht();\n    if (null !== t) {\n      const i = this.bt.Mn(),\n        n = this.bt.Sn();\n      this.kc(i, n, null, t);\n    }\n    this.bt.Dn();\n  }\n  Tc(t, i, n) {\n    const s = this.bo.vn(0);\n    void 0 !== i && void 0 !== n && this.bo.gt(i, n);\n    const e = this.bo.vn(0),\n      r = this.bo.su(),\n      h = this.bo.zs();\n    if (null !== h && null !== s && null !== e) {\n      const i = h.Ir(r),\n        n = s.__ > e.__,\n        l = null !== t && t > r && !n,\n        a = i && this.bo.F().shiftVisibleRangeOnNewBar;\n      if (l && !a) {\n        const i = t - r;\n        this.bo.Gn(this.bo.au() - i);\n      }\n    }\n    this.bo.du(t);\n  }\n  bl(t) {\n    null !== t && t.Yo();\n  }\n  Ke(t) {\n    const i = this.$u.find(i => i.Ga().includes(t));\n    return void 0 === i ? null : i;\n  }\n  hu() {\n    this.Ju.Dn(), this.$u.forEach(t => t.Yo()), this.pl();\n  }\n  M() {\n    this.$u.forEach(t => t.M()), this.$u.length = 0, this.un.localization.priceFormatter = void 0, this.un.localization.timeFormatter = void 0;\n  }\n  Pc() {\n    return this.Ku;\n  }\n  tr() {\n    return this.Ku.F();\n  }\n  To() {\n    return this.qu;\n  }\n  Rc(t, i) {\n    const n = this.$u[0],\n      s = this.Dc(i, t, n);\n    return this.Hu.push(s), 1 === this.Hu.length ? this.dl() : this.Ch(), s;\n  }\n  Bc(t) {\n    const i = this.Ke(t),\n      n = this.Hu.indexOf(t);\n    a(-1 !== n, \"Series not found\"), this.Hu.splice(n, 1), _(i).io(t), t.M && t.M();\n  }\n  cl(t, i) {\n    const n = _(this.Ke(t));\n    n.io(t);\n    const s = this.oc(i);\n    if (null === s) {\n      const s = t.Zi();\n      n.Ja(t, i, s);\n    } else {\n      const e = s.Ht === n ? t.Zi() : void 0;\n      s.Ht.Ja(t, i, e);\n    }\n  }\n  ku() {\n    const t = et.ns();\n    t.$n(), this.sc(t);\n  }\n  Oc(t) {\n    const i = et.ns();\n    i.qn(t), this.sc(i);\n  }\n  Zn() {\n    const t = et.ns();\n    t.Zn(), this.sc(t);\n  }\n  Kn(t) {\n    const i = et.ns();\n    i.Kn(t), this.sc(i);\n  }\n  Gn(t) {\n    const i = et.ns();\n    i.Gn(t), this.sc(i);\n  }\n  Yn(t) {\n    const i = et.ns();\n    i.Yn(t), this.sc(i);\n  }\n  Hn() {\n    const t = et.ns();\n    t.Hn(), this.sc(t);\n  }\n  Ac() {\n    return this.un.rightPriceScale.visible ? \"right\" : \"left\";\n  }\n  Lc() {\n    return this.nc;\n  }\n  U() {\n    return this.tc;\n  }\n  Lt(t) {\n    const i = this.nc,\n      n = this.tc;\n    if (i === n) return i;\n    if (t = Math.max(0, Math.min(100, Math.round(100 * t))), null === this.Xu || this.Xu.bs !== n || this.Xu.gs !== i) this.Xu = {\n      bs: n,\n      gs: i,\n      Ic: new Map()\n    };else {\n      const i = this.Xu.Ic.get(t);\n      if (void 0 !== i) return i;\n    }\n    const s = function (t, i, n) {\n      const [s, e, r, h] = g(t),\n        [l, a, o, _] = g(i),\n        u = [d(s + n * (l - s)), d(e + n * (a - e)), d(r + n * (o - r)), f(h + n * (_ - h))];\n      return \"rgba(\".concat(u[0], \", \").concat(u[1], \", \").concat(u[2], \", \").concat(u[3], \")\");\n    }(n, i, t / 100);\n    return this.Xu.Ic.set(t, s), s;\n  }\n  vc(t, i) {\n    const n = new et(i);\n    if (null !== t) {\n      const s = this.$u.indexOf(t);\n      n.zn(s, {\n        Nn: i\n      });\n    }\n    return n;\n  }\n  ec(t, i) {\n    return void 0 === i && (i = 2), this.vc(this.Ke(t), i);\n  }\n  sc(t) {\n    this.Zu && this.Zu(t), this.$u.forEach(t => t.Zo().Th().gt());\n  }\n  Dc(t, i, n) {\n    const s = new Ti(this, t, i),\n      e = void 0 !== t.priceScaleId ? t.priceScaleId : this.Ac();\n    return n.Ja(s, e), st(e) || s.kh(t), s;\n  }\n  ic(t) {\n    const i = this.un.layout;\n    return \"gradient\" === i.background.type ? 0 === t ? i.background.topColor : i.background.bottomColor : i.background.color;\n  }\n}\nfunction bn(t) {\n  return !x(t) && !k(t);\n}\nfunction gn(t) {\n  return x(t);\n}\n!function (t) {\n  t[t.Disabled = 0] = \"Disabled\", t[t.Continuous = 1] = \"Continuous\", t[t.OnDataUpdate = 2] = \"OnDataUpdate\";\n}(_n || (_n = {})), function (t) {\n  t[t.LastBar = 0] = \"LastBar\", t[t.LastVisible = 1] = \"LastVisible\";\n}(un || (un = {})), function (t) {\n  t.Solid = \"solid\", t.VerticalGradient = \"gradient\";\n}(cn || (cn = {}));\nconst wn = \"undefined\" != typeof window;\nfunction Mn() {\n  return !!wn && window.navigator.userAgent.toLowerCase().indexOf(\"firefox\") > -1;\n}\nfunction Sn() {\n  return !!wn && /iPhone|iPad|iPod/.test(window.navigator.platform);\n}\nfunction xn(t) {\n  return t + t % 2;\n}\nfunction yn(t, i) {\n  return t.Ec - i.Ec;\n}\nfunction kn(t, i, n) {\n  const s = (t.Ec - i.Ec) / (t._t - i._t);\n  return Math.sign(s) * Math.min(Math.abs(s), n);\n}\nclass Cn {\n  constructor(t, i, n, s) {\n    this.Vc = null, this.zc = null, this.Nc = null, this.Fc = null, this.Wc = null, this.jc = 0, this.$c = 0, this.Hc = t, this.Uc = i, this.qc = n, this.es = s;\n  }\n  Yc(t, i) {\n    if (null !== this.Vc) {\n      if (this.Vc._t === i) return void (this.Vc.Ec = t);\n      if (Math.abs(this.Vc.Ec - t) < this.es) return;\n    }\n    this.Fc = this.Nc, this.Nc = this.zc, this.zc = this.Vc, this.Vc = {\n      _t: i,\n      Ec: t\n    };\n  }\n  pr(t, i) {\n    if (null === this.Vc || null === this.zc) return;\n    if (i - this.Vc._t > 50) return;\n    let n = 0;\n    const s = kn(this.Vc, this.zc, this.Uc),\n      e = yn(this.Vc, this.zc),\n      r = [s],\n      h = [e];\n    if (n += e, null !== this.Nc) {\n      const t = kn(this.zc, this.Nc, this.Uc);\n      if (Math.sign(t) === Math.sign(s)) {\n        const i = yn(this.zc, this.Nc);\n        if (r.push(t), h.push(i), n += i, null !== this.Fc) {\n          const t = kn(this.Nc, this.Fc, this.Uc);\n          if (Math.sign(t) === Math.sign(s)) {\n            const i = yn(this.Nc, this.Fc);\n            r.push(t), h.push(i), n += i;\n          }\n        }\n      }\n    }\n    let l = 0;\n    for (let t = 0; t < r.length; ++t) l += h[t] / n * r[t];\n    Math.abs(l) < this.Hc || (this.Wc = {\n      Ec: t,\n      _t: i\n    }, this.$c = l, this.jc = function (t, i) {\n      const n = Math.log(i);\n      return Math.log(1 * n / -t) / n;\n    }(Math.abs(l), this.qc));\n  }\n  wu(t) {\n    const i = _(this.Wc),\n      n = t - i._t;\n    return i.Ec + this.$c * (Math.pow(this.qc, n) - 1) / Math.log(this.qc);\n  }\n  gu(t) {\n    return null === this.Wc || this.Xc(t) === this.jc;\n  }\n  Xc(t) {\n    const i = t - _(this.Wc)._t;\n    return Math.min(i, this.jc);\n  }\n}\nfunction Tn(t, n) {\n  const s = _(t.ownerDocument).createElement(\"canvas\");\n  t.appendChild(s);\n  const e = i(s, {\n    type: \"device-pixel-content-box\",\n    options: {\n      allowResizeObserver: !1\n    },\n    transform: (t, i) => ({\n      width: Math.max(t.width, i.width),\n      height: Math.max(t.height, i.height)\n    })\n  });\n  return e.resizeCanvasElement(n), e;\n}\nfunction Pn(t) {\n  wn && void 0 !== window.chrome && t.addEventListener(\"mousedown\", t => {\n    if (1 === t.button) return t.preventDefault(), !1;\n  });\n}\nclass Rn {\n  constructor(t, i, n) {\n    this.Zc = 0, this.Kc = null, this.Gc = {\n      st: Number.NEGATIVE_INFINITY,\n      et: Number.POSITIVE_INFINITY\n    }, this.Jc = 0, this.Qc = null, this.td = {\n      st: Number.NEGATIVE_INFINITY,\n      et: Number.POSITIVE_INFINITY\n    }, this.nd = null, this.sd = !1, this.ed = null, this.rd = null, this.hd = !1, this.ld = !1, this.ad = !1, this.od = null, this._d = null, this.ud = null, this.dd = null, this.fd = null, this.pd = null, this.vd = null, this.md = 0, this.bd = !1, this.gd = !1, this.wd = !1, this.Md = 0, this.Sd = null, this.xd = !Sn(), this.yd = t => {\n      this.kd(t);\n    }, this.Cd = t => {\n      if (this.Td(t)) {\n        const i = this.Pd(t);\n        if (++this.Jc, this.Qc && this.Jc > 1) {\n          const {\n            Rd: n\n          } = this.Dd(On(t), this.td);\n          n < 30 && !this.ad && this.Bd(i, this.Ad.Od), this.Ld();\n        }\n      } else {\n        const i = this.Pd(t);\n        if (++this.Zc, this.Kc && this.Zc > 1) {\n          const {\n            Rd: n\n          } = this.Dd(On(t), this.Gc);\n          n < 5 && !this.ld && this.Id(i, this.Ad.Ed), this.Vd();\n        }\n      }\n    }, this.zd = t, this.Ad = i, this.un = n, this.Nd();\n  }\n  M() {\n    null !== this.od && (this.od(), this.od = null), null !== this._d && (this._d(), this._d = null), null !== this.dd && (this.dd(), this.dd = null), null !== this.fd && (this.fd(), this.fd = null), null !== this.pd && (this.pd(), this.pd = null), null !== this.ud && (this.ud(), this.ud = null), this.Fd(), this.Vd();\n  }\n  Wd(t) {\n    this.dd && this.dd();\n    const i = this.jd.bind(this);\n    if (this.dd = () => {\n      this.zd.removeEventListener(\"mousemove\", i);\n    }, this.zd.addEventListener(\"mousemove\", i), this.Td(t)) return;\n    const n = this.Pd(t);\n    this.Id(n, this.Ad.$d), this.xd = !0;\n  }\n  Vd() {\n    null !== this.Kc && clearTimeout(this.Kc), this.Zc = 0, this.Kc = null, this.Gc = {\n      st: Number.NEGATIVE_INFINITY,\n      et: Number.POSITIVE_INFINITY\n    };\n  }\n  Ld() {\n    null !== this.Qc && clearTimeout(this.Qc), this.Jc = 0, this.Qc = null, this.td = {\n      st: Number.NEGATIVE_INFINITY,\n      et: Number.POSITIVE_INFINITY\n    };\n  }\n  jd(t) {\n    if (this.wd || null !== this.rd) return;\n    if (this.Td(t)) return;\n    const i = this.Pd(t);\n    this.Id(i, this.Ad.Hd), this.xd = !0;\n  }\n  Ud(t) {\n    const i = Ln(t.changedTouches, _(this.Sd));\n    if (null === i) return;\n    if (this.Md = An(t), null !== this.vd) return;\n    if (this.gd) return;\n    this.bd = !0;\n    const n = this.Dd(On(i), _(this.rd)),\n      {\n        qd: s,\n        Yd: e,\n        Rd: r\n      } = n;\n    if (this.hd || !(r < 5)) {\n      if (!this.hd) {\n        const t = .5 * s,\n          i = e >= t && !this.un.Xd(),\n          n = t > e && !this.un.Zd();\n        i || n || (this.gd = !0), this.hd = !0, this.ad = !0, this.Fd(), this.Ld();\n      }\n      if (!this.gd) {\n        const n = this.Pd(t, i);\n        this.Bd(n, this.Ad.Kd), Bn(t);\n      }\n    }\n  }\n  Gd(t) {\n    if (0 !== t.button) return;\n    const i = this.Dd(On(t), _(this.ed)),\n      {\n        Rd: n\n      } = i;\n    if (n >= 5 && (this.ld = !0, this.Vd()), this.ld) {\n      const i = this.Pd(t);\n      this.Id(i, this.Ad.Jd);\n    }\n  }\n  Dd(t, i) {\n    const n = Math.abs(i.st - t.st),\n      s = Math.abs(i.et - t.et);\n    return {\n      qd: n,\n      Yd: s,\n      Rd: n + s\n    };\n  }\n  Qd(t) {\n    let i = Ln(t.changedTouches, _(this.Sd));\n    if (null === i && 0 === t.touches.length && (i = t.changedTouches[0]), null === i) return;\n    this.Sd = null, this.Md = An(t), this.Fd(), this.rd = null, this.pd && (this.pd(), this.pd = null);\n    const n = this.Pd(t, i);\n    if (this.Bd(n, this.Ad.tf), ++this.Jc, this.Qc && this.Jc > 1) {\n      const {\n        Rd: t\n      } = this.Dd(On(i), this.td);\n      t < 30 && !this.ad && this.Bd(n, this.Ad.Od), this.Ld();\n    } else this.ad || (this.Bd(n, this.Ad.if), this.Ad.if && Bn(t));\n    0 === this.Jc && Bn(t), 0 === t.touches.length && this.sd && (this.sd = !1, Bn(t));\n  }\n  kd(t) {\n    if (0 !== t.button) return;\n    const i = this.Pd(t);\n    if (this.ed = null, this.wd = !1, this.fd && (this.fd(), this.fd = null), Mn()) {\n      this.zd.ownerDocument.documentElement.removeEventListener(\"mouseleave\", this.yd);\n    }\n    if (!this.Td(t)) if (this.Id(i, this.Ad.nf), ++this.Zc, this.Kc && this.Zc > 1) {\n      const {\n        Rd: n\n      } = this.Dd(On(t), this.Gc);\n      n < 5 && !this.ld && this.Id(i, this.Ad.Ed), this.Vd();\n    } else this.ld || this.Id(i, this.Ad.sf);\n  }\n  Fd() {\n    null !== this.nd && (clearTimeout(this.nd), this.nd = null);\n  }\n  ef(t) {\n    if (null !== this.Sd) return;\n    const i = t.changedTouches[0];\n    this.Sd = i.identifier, this.Md = An(t);\n    const n = this.zd.ownerDocument.documentElement;\n    this.ad = !1, this.hd = !1, this.gd = !1, this.rd = On(i), this.pd && (this.pd(), this.pd = null);\n    {\n      const i = this.Ud.bind(this),\n        s = this.Qd.bind(this);\n      this.pd = () => {\n        n.removeEventListener(\"touchmove\", i), n.removeEventListener(\"touchend\", s);\n      }, n.addEventListener(\"touchmove\", i, {\n        passive: !1\n      }), n.addEventListener(\"touchend\", s, {\n        passive: !1\n      }), this.Fd(), this.nd = setTimeout(this.rf.bind(this, t), 240);\n    }\n    const s = this.Pd(t, i);\n    this.Bd(s, this.Ad.hf), this.Qc || (this.Jc = 0, this.Qc = setTimeout(this.Ld.bind(this), 500), this.td = On(i));\n  }\n  lf(t) {\n    if (0 !== t.button) return;\n    const i = this.zd.ownerDocument.documentElement;\n    Mn() && i.addEventListener(\"mouseleave\", this.yd), this.ld = !1, this.ed = On(t), this.fd && (this.fd(), this.fd = null);\n    {\n      const t = this.Gd.bind(this),\n        n = this.kd.bind(this);\n      this.fd = () => {\n        i.removeEventListener(\"mousemove\", t), i.removeEventListener(\"mouseup\", n);\n      }, i.addEventListener(\"mousemove\", t), i.addEventListener(\"mouseup\", n);\n    }\n    if (this.wd = !0, this.Td(t)) return;\n    const n = this.Pd(t);\n    this.Id(n, this.Ad.af), this.Kc || (this.Zc = 0, this.Kc = setTimeout(this.Vd.bind(this), 500), this.Gc = On(t));\n  }\n  Nd() {\n    this.zd.addEventListener(\"mouseenter\", this.Wd.bind(this)), this.zd.addEventListener(\"touchcancel\", this.Fd.bind(this));\n    {\n      const t = this.zd.ownerDocument,\n        i = t => {\n          this.Ad._f && (t.composed && this.zd.contains(t.composedPath()[0]) || t.target && this.zd.contains(t.target) || this.Ad._f());\n        };\n      this._d = () => {\n        t.removeEventListener(\"touchstart\", i);\n      }, this.od = () => {\n        t.removeEventListener(\"mousedown\", i);\n      }, t.addEventListener(\"mousedown\", i), t.addEventListener(\"touchstart\", i, {\n        passive: !0\n      });\n    }\n    Sn() && (this.ud = () => {\n      this.zd.removeEventListener(\"dblclick\", this.Cd);\n    }, this.zd.addEventListener(\"dblclick\", this.Cd)), this.zd.addEventListener(\"mouseleave\", this.uf.bind(this)), this.zd.addEventListener(\"touchstart\", this.ef.bind(this), {\n      passive: !0\n    }), Pn(this.zd), this.zd.addEventListener(\"mousedown\", this.lf.bind(this)), this.cf(), this.zd.addEventListener(\"touchmove\", () => {}, {\n      passive: !1\n    });\n  }\n  cf() {\n    void 0 === this.Ad.df && void 0 === this.Ad.ff && void 0 === this.Ad.pf || (this.zd.addEventListener(\"touchstart\", t => this.vf(t.touches), {\n      passive: !0\n    }), this.zd.addEventListener(\"touchmove\", t => {\n      if (2 === t.touches.length && null !== this.vd && void 0 !== this.Ad.ff) {\n        const i = Dn(t.touches[0], t.touches[1]) / this.md;\n        this.Ad.ff(this.vd, i), Bn(t);\n      }\n    }, {\n      passive: !1\n    }), this.zd.addEventListener(\"touchend\", t => {\n      this.vf(t.touches);\n    }));\n  }\n  vf(t) {\n    1 === t.length && (this.bd = !1), 2 !== t.length || this.bd || this.sd ? this.mf() : this.bf(t);\n  }\n  bf(t) {\n    const i = this.zd.getBoundingClientRect() || {\n      left: 0,\n      top: 0\n    };\n    this.vd = {\n      st: (t[0].clientX - i.left + (t[1].clientX - i.left)) / 2,\n      et: (t[0].clientY - i.top + (t[1].clientY - i.top)) / 2\n    }, this.md = Dn(t[0], t[1]), void 0 !== this.Ad.df && this.Ad.df(), this.Fd();\n  }\n  mf() {\n    null !== this.vd && (this.vd = null, void 0 !== this.Ad.pf && this.Ad.pf());\n  }\n  uf(t) {\n    if (this.dd && this.dd(), this.Td(t)) return;\n    if (!this.xd) return;\n    const i = this.Pd(t);\n    this.Id(i, this.Ad.gf), this.xd = !Sn();\n  }\n  rf(t) {\n    const i = Ln(t.touches, _(this.Sd));\n    if (null === i) return;\n    const n = this.Pd(t, i);\n    this.Bd(n, this.Ad.wf), this.ad = !0, this.sd = !0;\n  }\n  Td(t) {\n    return t.sourceCapabilities && void 0 !== t.sourceCapabilities.firesTouchEvents ? t.sourceCapabilities.firesTouchEvents : An(t) < this.Md + 500;\n  }\n  Bd(t, i) {\n    i && i.call(this.Ad, t);\n  }\n  Id(t, i) {\n    i && i.call(this.Ad, t);\n  }\n  Pd(t, i) {\n    const n = i || t,\n      s = this.zd.getBoundingClientRect() || {\n        left: 0,\n        top: 0\n      };\n    return {\n      clientX: n.clientX,\n      clientY: n.clientY,\n      pageX: n.pageX,\n      pageY: n.pageY,\n      screenX: n.screenX,\n      screenY: n.screenY,\n      localX: n.clientX - s.left,\n      localY: n.clientY - s.top,\n      ctrlKey: t.ctrlKey,\n      altKey: t.altKey,\n      shiftKey: t.shiftKey,\n      metaKey: t.metaKey,\n      Mf: !t.type.startsWith(\"mouse\") && \"contextmenu\" !== t.type && \"click\" !== t.type,\n      Sf: t.type,\n      xf: n.target,\n      yf: t.view,\n      kf: () => {\n        \"touchstart\" !== t.type && Bn(t);\n      }\n    };\n  }\n}\nfunction Dn(t, i) {\n  const n = t.clientX - i.clientX,\n    s = t.clientY - i.clientY;\n  return Math.sqrt(n * n + s * s);\n}\nfunction Bn(t) {\n  t.cancelable && t.preventDefault();\n}\nfunction On(t) {\n  return {\n    st: t.pageX,\n    et: t.pageY\n  };\n}\nfunction An(t) {\n  return t.timeStamp || performance.now();\n}\nfunction Ln(t, i) {\n  for (let n = 0; n < t.length; ++n) if (t[n].identifier === i) return t[n];\n  return null;\n}\nclass In {\n  constructor(i, n, s, e) {\n    this.Vi = null, this.Cf = null, this.Tf = !1, this.Pf = new Ht(200), this.Vr = null, this.Rf = 0, this.Df = !1, this.Bf = () => {\n      this.Df || this.tn.Of().Ut().Ch();\n    }, this.Af = () => {\n      this.Df || this.tn.Of().Ut().Ch();\n    }, this.tn = i, this.un = n, this.Da = n.layout, this.Ku = s, this.Lf = \"left\" === e, this.If = document.createElement(\"div\"), this.If.style.height = \"100%\", this.If.style.overflow = \"hidden\", this.If.style.width = \"25px\", this.If.style.left = \"0\", this.If.style.position = \"relative\", this.Ef = Tn(this.If, t({\n      width: 16,\n      height: 16\n    })), this.Ef.subscribeSuggestedBitmapSizeChanged(this.Bf);\n    const r = this.Ef.canvasElement;\n    r.style.position = \"absolute\", r.style.zIndex = \"1\", r.style.left = \"0\", r.style.top = \"0\", this.Vf = Tn(this.If, t({\n      width: 16,\n      height: 16\n    })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Af);\n    const h = this.Vf.canvasElement;\n    h.style.position = \"absolute\", h.style.zIndex = \"2\", h.style.left = \"0\", h.style.top = \"0\";\n    const l = {\n      af: this.zf.bind(this),\n      hf: this.zf.bind(this),\n      Jd: this.Nf.bind(this),\n      Kd: this.Nf.bind(this),\n      _f: this.Ff.bind(this),\n      nf: this.Wf.bind(this),\n      tf: this.Wf.bind(this),\n      Ed: this.jf.bind(this),\n      Od: this.jf.bind(this),\n      $d: this.$f.bind(this),\n      gf: this.Hf.bind(this)\n    };\n    this.Uf = new Rn(this.Vf.canvasElement, l, {\n      Xd: () => !1,\n      Zd: () => !0\n    });\n  }\n  M() {\n    this.Uf.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.Vf.dispose(), this.Ef.unsubscribeSuggestedBitmapSizeChanged(this.Bf), this.Ef.dispose(), null !== this.Vi && this.Vi.so().v(this), this.Vi = null;\n  }\n  qf() {\n    return this.If;\n  }\n  T() {\n    return this.Da.fontSize;\n  }\n  Yf() {\n    const t = this.Ku.F();\n    return this.Vr !== t.P && (this.Pf.Fe(), this.Vr = t.P), t;\n  }\n  Xf() {\n    if (null === this.Vi) return 0;\n    let t = 0;\n    const i = this.Yf(),\n      n = _(this.Ef.canvasElement.getContext(\"2d\"));\n    n.save();\n    const s = this.Vi.Gl();\n    n.font = this.Zf(), s.length > 0 && (t = Math.max(this.Pf.Si(n, s[0]._a), this.Pf.Si(n, s[s.length - 1]._a)));\n    const e = this.Kf();\n    for (let i = e.length; i--;) {\n      const s = this.Pf.Si(n, e[i].Gt());\n      s > t && (t = s);\n    }\n    const r = this.Vi.Tt();\n    if (null !== r && null !== this.Cf) {\n      const i = this.Vi.pn(1, r),\n        s = this.Vi.pn(this.Cf.height - 2, r);\n      t = Math.max(t, this.Pf.Si(n, this.Vi.Fi(Math.floor(Math.min(i, s)) + .11111111111111, r)), this.Pf.Si(n, this.Vi.Fi(Math.ceil(Math.max(i, s)) - .11111111111111, r)));\n    }\n    n.restore();\n    const h = t || 34;\n    return xn(Math.ceil(i.k + i.C + i.A + i.L + 5 + h));\n  }\n  Gf(t) {\n    null !== this.Cf && n(this.Cf, t) || (this.Cf = t, this.Df = !0, this.Ef.resizeCanvasElement(t), this.Vf.resizeCanvasElement(t), this.Df = !1, this.If.style.width = \"\".concat(t.width, \"px\"), this.If.style.height = \"\".concat(t.height, \"px\"));\n  }\n  Jf() {\n    return _(this.Cf).width;\n  }\n  Gi(t) {\n    this.Vi !== t && (null !== this.Vi && this.Vi.so().v(this), this.Vi = t, t.so().l(this.Ma.bind(this), this));\n  }\n  Bt() {\n    return this.Vi;\n  }\n  Fe() {\n    const t = this.tn.Qf();\n    this.tn.Of().Ut().Uo(t, _(this.Bt()));\n  }\n  tp(t) {\n    if (null === this.Cf) return;\n    if (1 !== t) {\n      this.ip(), this.Ef.applySuggestedBitmapSize();\n      const t = s(this.Ef);\n      null !== t && (t.useBitmapCoordinateSpace(t => {\n        this.np(t), this.ye(t);\n      }), this.sp(t), this.ep(t));\n    }\n    this.Vf.applySuggestedBitmapSize();\n    const i = s(this.Vf);\n    null !== i && (i.useBitmapCoordinateSpace(_ref11 => {\n      let {\n        context: t,\n        bitmapSize: i\n      } = _ref11;\n      t.clearRect(0, 0, i.width, i.height);\n    }), this.rp(i));\n  }\n  hp() {\n    return this.Ef.bitmapSize;\n  }\n  lp(t, i, n) {\n    const s = this.hp();\n    s.width > 0 && s.height > 0 && t.drawImage(this.Ef.canvasElement, i, n);\n  }\n  gt() {\n    var t;\n    null === (t = this.Vi) || void 0 === t || t.Gl();\n  }\n  zf(t) {\n    if (null === this.Vi || this.Vi.Ni() || !this.un.handleScale.axisPressedMouseMove.price) return;\n    const i = this.tn.Of().Ut(),\n      n = this.tn.Qf();\n    this.Tf = !0, i.zo(n, this.Vi, t.localY);\n  }\n  Nf(t) {\n    if (null === this.Vi || !this.un.handleScale.axisPressedMouseMove.price) return;\n    const i = this.tn.Of().Ut(),\n      n = this.tn.Qf(),\n      s = this.Vi;\n    i.No(n, s, t.localY);\n  }\n  Ff() {\n    if (null === this.Vi || !this.un.handleScale.axisPressedMouseMove.price) return;\n    const t = this.tn.Of().Ut(),\n      i = this.tn.Qf(),\n      n = this.Vi;\n    this.Tf && (this.Tf = !1, t.Fo(i, n));\n  }\n  Wf(t) {\n    if (null === this.Vi || !this.un.handleScale.axisPressedMouseMove.price) return;\n    const i = this.tn.Of().Ut(),\n      n = this.tn.Qf();\n    this.Tf = !1, i.Fo(n, this.Vi);\n  }\n  jf(t) {\n    this.un.handleScale.axisDoubleClickReset.price && this.Fe();\n  }\n  $f(t) {\n    if (null === this.Vi) return;\n    !this.tn.Of().Ut().F().handleScale.axisPressedMouseMove.price || this.Vi.th() || this.Vi.za() || this.ap(1);\n  }\n  Hf(t) {\n    this.ap(0);\n  }\n  Kf() {\n    const t = [],\n      i = null === this.Vi ? void 0 : this.Vi;\n    return (n => {\n      for (let s = 0; s < n.length; ++s) {\n        const e = n[s].Pn(this.tn.Qf(), i);\n        for (let i = 0; i < e.length; i++) t.push(e[i]);\n      }\n    })(this.tn.Qf().Ga()), t;\n  }\n  np(_ref12) {\n    let {\n      context: t,\n      bitmapSize: i\n    } = _ref12;\n    const {\n        width: n,\n        height: s\n      } = i,\n      e = this.tn.Qf().Ut(),\n      r = e.U(),\n      h = e.Lc();\n    r === h ? $(t, 0, 0, n, s, r) : Y(t, 0, 0, n, s, r, h);\n  }\n  ye(_ref13) {\n    let {\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: n\n    } = _ref13;\n    if (null === this.Cf || null === this.Vi || !this.Vi.F().borderVisible) return;\n    t.fillStyle = this.Vi.F().borderColor;\n    const s = Math.max(1, Math.floor(this.Yf().k * n));\n    let e;\n    e = this.Lf ? i.width - s : 0, t.fillRect(e, 0, s, i.height);\n  }\n  sp(t) {\n    if (null === this.Cf || null === this.Vi) return;\n    const i = this.Vi.Gl(),\n      n = this.Vi.F(),\n      s = this.Yf(),\n      e = this.Lf ? this.Cf.width - s.C : 0;\n    n.borderVisible && n.ticksVisible && t.useBitmapCoordinateSpace(_ref14 => {\n      let {\n        context: t,\n        horizontalPixelRatio: r,\n        verticalPixelRatio: h\n      } = _ref14;\n      t.fillStyle = n.borderColor;\n      const l = Math.max(1, Math.floor(h)),\n        a = Math.floor(.5 * h),\n        o = Math.round(s.C * r);\n      t.beginPath();\n      for (const n of i) t.rect(Math.floor(e * r), Math.round(n.ql * h) - a, o, l);\n      t.fill();\n    }), t.useMediaCoordinateSpace(_ref15 => {\n      let {\n        context: t\n      } = _ref15;\n      var r;\n      t.font = this.Zf(), t.fillStyle = null !== (r = n.textColor) && void 0 !== r ? r : this.Da.textColor, t.textAlign = this.Lf ? \"right\" : \"left\", t.textBaseline = \"middle\";\n      const h = this.Lf ? Math.round(e - s.A) : Math.round(e + s.C + s.A),\n        l = i.map(i => this.Pf.Mi(t, i._a));\n      for (let n = i.length; n--;) {\n        const s = i[n];\n        t.fillText(s._a, h, s.ql + l[n]);\n      }\n    });\n  }\n  ip() {\n    if (null === this.Cf || null === this.Vi) return;\n    let t = this.Cf.height / 2;\n    const i = [],\n      n = this.Vi.Ga().slice(),\n      s = this.tn.Qf(),\n      e = this.Yf();\n    this.Vi === s.Je() && this.tn.Qf().Ga().forEach(t => {\n      s.Ge(t) && n.push(t);\n    });\n    const r = this.Vi.Wl()[0],\n      h = this.Vi;\n    n.forEach(n => {\n      const e = n.Pn(s, h);\n      e.forEach(t => {\n        t.Oi(null), t.Ai() && i.push(t);\n      }), r === n && e.length > 0 && (t = e[0].yi());\n    }), i.forEach(t => t.Oi(t.yi()));\n    this.Vi.F().alignLabels && this.op(i, e, t);\n  }\n  op(t, i, n) {\n    if (null === this.Cf) return;\n    const s = t.filter(t => t.yi() <= n),\n      e = t.filter(t => t.yi() > n);\n    s.sort((t, i) => i.yi() - t.yi()), s.length && e.length && e.push(s[0]), e.sort((t, i) => t.yi() - i.yi());\n    for (const n of t) {\n      const t = Math.floor(n.It(i) / 2),\n        s = n.yi();\n      s > -t && s < t && n.Oi(t), s > this.Cf.height - t && s < this.Cf.height + t && n.Oi(this.Cf.height - t);\n    }\n    for (let t = 1; t < s.length; t++) {\n      const n = s[t],\n        e = s[t - 1],\n        r = e.It(i, !1),\n        h = n.yi(),\n        l = e.Bi();\n      h > l - r && n.Oi(l - r);\n    }\n    for (let t = 1; t < e.length; t++) {\n      const n = e[t],\n        s = e[t - 1],\n        r = s.It(i, !0),\n        h = n.yi(),\n        l = s.Bi();\n      h < l + r && n.Oi(l + r);\n    }\n  }\n  ep(t) {\n    if (null === this.Cf) return;\n    const i = this.Kf(),\n      n = this.Yf(),\n      s = this.Lf ? \"right\" : \"left\";\n    i.forEach(i => {\n      if (i.Li()) {\n        i.Mt(_(this.Vi)).X(t, n, this.Pf, s);\n      }\n    });\n  }\n  rp(t) {\n    if (null === this.Cf || null === this.Vi) return;\n    const i = this.tn.Of().Ut(),\n      n = [],\n      s = this.tn.Qf(),\n      e = i.cc().Pn(s, this.Vi);\n    e.length && n.push(e);\n    const r = this.Yf(),\n      h = this.Lf ? \"right\" : \"left\";\n    n.forEach(i => {\n      i.forEach(i => {\n        i.Mt(_(this.Vi)).X(t, r, this.Pf, h);\n      });\n    });\n  }\n  ap(t) {\n    this.If.style.cursor = 1 === t ? \"ns-resize\" : \"default\";\n  }\n  Ma() {\n    const t = this.Xf();\n    this.Rf < t && this.tn.Of().Ut().dl(), this.Rf = t;\n  }\n  Zf() {\n    return B(this.Da.fontSize, this.Da.fontFamily);\n  }\n}\nfunction En(t, i, n, s) {\n  t.K && t.K(i, n, s);\n}\nfunction Vn(t, i, n, s) {\n  t.X(i, n, s);\n}\nfunction zn(t, i) {\n  return t.Tn(i);\n}\nfunction Nn(t, i) {\n  return t.Ji(i);\n}\nfunction Fn(t, i) {\n  return void 0 !== t.kl ? t.kl(i) : [];\n}\nclass Wn {\n  constructor(i, n) {\n    this.Cf = t({\n      width: 0,\n      height: 0\n    }), this._p = null, this.up = null, this.cp = null, this.dp = !1, this.fp = new M(), this.pp = 0, this.vp = !1, this.mp = null, this.bp = !1, this.gp = null, this.wp = null, this.Df = !1, this.Bf = () => {\n      this.Df || null === this.Mp || this.Hi().Ch();\n    }, this.Af = () => {\n      this.Df || null === this.Mp || this.Hi().Ch();\n    }, this.Sp = i, this.Mp = n, this.Mp.Xo().l(this.xp.bind(this), this, !0), this.yp = document.createElement(\"td\"), this.yp.style.padding = \"0\", this.yp.style.position = \"relative\";\n    const s = document.createElement(\"div\");\n    s.style.width = \"100%\", s.style.height = \"100%\", s.style.position = \"relative\", s.style.overflow = \"hidden\", this.kp = document.createElement(\"td\"), this.kp.style.padding = \"0\", this.Cp = document.createElement(\"td\"), this.Cp.style.padding = \"0\", this.yp.appendChild(s), this.Ef = Tn(s, t({\n      width: 16,\n      height: 16\n    })), this.Ef.subscribeSuggestedBitmapSizeChanged(this.Bf);\n    const e = this.Ef.canvasElement;\n    e.style.position = \"absolute\", e.style.zIndex = \"1\", e.style.left = \"0\", e.style.top = \"0\", this.Vf = Tn(s, t({\n      width: 16,\n      height: 16\n    })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Af);\n    const r = this.Vf.canvasElement;\n    r.style.position = \"absolute\", r.style.zIndex = \"2\", r.style.left = \"0\", r.style.top = \"0\", this.Tp = document.createElement(\"tr\"), this.Tp.appendChild(this.kp), this.Tp.appendChild(this.yp), this.Tp.appendChild(this.Cp), this.Pp(), this.Uf = new Rn(this.Vf.canvasElement, this, {\n      Xd: () => null === this.mp && !this.Sp.F().handleScroll.vertTouchDrag,\n      Zd: () => null === this.mp && !this.Sp.F().handleScroll.horzTouchDrag\n    });\n  }\n  M() {\n    null !== this._p && this._p.M(), null !== this.up && this.up.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.Vf.dispose(), this.Ef.unsubscribeSuggestedBitmapSizeChanged(this.Bf), this.Ef.dispose(), null !== this.Mp && this.Mp.Xo().v(this), this.Uf.M();\n  }\n  Qf() {\n    return _(this.Mp);\n  }\n  Rp(t) {\n    null !== this.Mp && this.Mp.Xo().v(this), this.Mp = t, null !== this.Mp && this.Mp.Xo().l(Wn.prototype.xp.bind(this), this, !0), this.Pp();\n  }\n  Of() {\n    return this.Sp;\n  }\n  qf() {\n    return this.Tp;\n  }\n  Pp() {\n    if (null !== this.Mp && (this.Dp(), 0 !== this.Hi().wt().length)) {\n      if (null !== this._p) {\n        const t = this.Mp.Eo();\n        this._p.Gi(_(t));\n      }\n      if (null !== this.up) {\n        const t = this.Mp.Vo();\n        this.up.Gi(_(t));\n      }\n    }\n  }\n  Bp() {\n    null !== this._p && this._p.gt(), null !== this.up && this.up.gt();\n  }\n  Po() {\n    return null !== this.Mp ? this.Mp.Po() : 0;\n  }\n  Ro(t) {\n    this.Mp && this.Mp.Ro(t);\n  }\n  $d(t) {\n    if (!this.Mp) return;\n    this.Op();\n    const i = t.localX,\n      n = t.localY;\n    this.Ap(i, n, t);\n  }\n  af(t) {\n    this.Op(), this.Lp(), this.Ap(t.localX, t.localY, t);\n  }\n  Hd(t) {\n    if (!this.Mp) return;\n    this.Op();\n    const i = t.localX,\n      n = t.localY;\n    this.Ap(i, n, t);\n    const s = this.ir(i, n);\n    this.Hi().hc(s && {\n      lc: s.lc,\n      Ip: s.Ip\n    });\n  }\n  sf(t) {\n    null !== this.Mp && (this.Op(), this.Ep(t));\n  }\n  Jd(t) {\n    this.Op(), this.Vp(t), this.Ap(t.localX, t.localY, t);\n  }\n  nf(t) {\n    null !== this.Mp && (this.Op(), this.vp = !1, this.zp(t));\n  }\n  if(t) {\n    null !== this.Mp && this.Ep(t);\n  }\n  wf(t) {\n    if (this.vp = !0, null === this.mp) {\n      const i = {\n        x: t.localX,\n        y: t.localY\n      };\n      this.Np(i, i, t);\n    }\n  }\n  gf(t) {\n    null !== this.Mp && (this.Op(), this.Mp.Ut().hc(null), this.Fp());\n  }\n  Wp() {\n    return this.fp;\n  }\n  df() {\n    this.pp = 1, this.Hi().Hn();\n  }\n  ff(t, i) {\n    if (!this.Sp.F().handleScale.pinch) return;\n    const n = 5 * (i - this.pp);\n    this.pp = i, this.Hi().bc(t.st, n);\n  }\n  hf(t) {\n    if (this.vp = !1, this.bp = null !== this.mp, this.Lp(), null !== this.mp) {\n      const i = this.Hi().cc();\n      this.gp = {\n        x: i.Xt(),\n        y: i.Zt()\n      }, this.mp = {\n        x: t.localX,\n        y: t.localY\n      };\n    }\n  }\n  Kd(t) {\n    if (null === this.Mp) return;\n    const i = t.localX,\n      n = t.localY;\n    if (null === this.mp) this.Vp(t);else {\n      this.bp = !1;\n      const s = _(this.gp),\n        e = s.x + (i - this.mp.x),\n        r = s.y + (n - this.mp.y);\n      this.Ap(e, r, t);\n    }\n  }\n  tf(t) {\n    0 === this.Of().F().trackingMode.exitMode && (this.bp = !0), this.jp(), this.zp(t);\n  }\n  ir(t, i) {\n    const n = this.Mp;\n    if (null === n) return null;\n    const s = n.Ga();\n    for (const e of s) {\n      const s = this.$p(e.Tn(n), t, i);\n      if (null !== s) return {\n        lc: e,\n        yf: s.yf,\n        Ip: s.Ip\n      };\n    }\n    return null;\n  }\n  Hp(i, n) {\n    _(\"left\" === n ? this._p : this.up).Gf(t({\n      width: i,\n      height: this.Cf.height\n    }));\n  }\n  Up() {\n    return this.Cf;\n  }\n  Gf(t) {\n    n(this.Cf, t) || (this.Cf = t, this.Df = !0, this.Ef.resizeCanvasElement(t), this.Vf.resizeCanvasElement(t), this.Df = !1, this.yp.style.width = t.width + \"px\", this.yp.style.height = t.height + \"px\");\n  }\n  qp() {\n    const t = _(this.Mp);\n    t.Io(t.Eo()), t.Io(t.Vo());\n    for (const i of t.Wl()) if (t.Ge(i)) {\n      const n = i.Bt();\n      null !== n && t.Io(n), i.Dn();\n    }\n  }\n  hp() {\n    return this.Ef.bitmapSize;\n  }\n  lp(t, i, n) {\n    const s = this.hp();\n    s.width > 0 && s.height > 0 && t.drawImage(this.Ef.canvasElement, i, n);\n  }\n  tp(t) {\n    if (0 === t) return;\n    if (null === this.Mp) return;\n    if (t > 1 && this.qp(), null !== this._p && this._p.tp(t), null !== this.up && this.up.tp(t), 1 !== t) {\n      this.Ef.applySuggestedBitmapSize();\n      const t = s(this.Ef);\n      null !== t && (t.useBitmapCoordinateSpace(t => {\n        this.np(t);\n      }), this.Mp && (this.Yp(t), this.Xp(t), this.Zp(t, zn), this.Zp(t, Nn)));\n    }\n    this.Vf.applySuggestedBitmapSize();\n    const i = s(this.Vf);\n    null !== i && (i.useBitmapCoordinateSpace(_ref16 => {\n      let {\n        context: t,\n        bitmapSize: i\n      } = _ref16;\n      t.clearRect(0, 0, i.width, i.height);\n    }), this.Zp(i, Fn), this.Kp(i));\n  }\n  Gp() {\n    return this._p;\n  }\n  Jp() {\n    return this.up;\n  }\n  xp() {\n    null !== this.Mp && this.Mp.Xo().v(this), this.Mp = null;\n  }\n  Ep(t) {\n    const i = t.localX,\n      n = t.localY;\n    this.fp.g() && this.fp.m(this.Hi().yt().eu(i), {\n      x: i,\n      y: n\n    }, t);\n  }\n  np(_ref17) {\n    let {\n      context: t,\n      bitmapSize: i\n    } = _ref17;\n    const {\n        width: n,\n        height: s\n      } = i,\n      e = this.Hi(),\n      r = e.U(),\n      h = e.Lc();\n    r === h ? $(t, 0, 0, n, s, h) : Y(t, 0, 0, n, s, r, h);\n  }\n  Yp(t) {\n    const i = _(this.Mp).Zo().Th().Mt();\n    null !== i && i.X(t, !1);\n  }\n  Xp(t) {\n    const i = this.Hi().uc();\n    this.Qp(t, zn, En, i), this.Qp(t, zn, Vn, i);\n  }\n  Kp(t) {\n    this.Qp(t, zn, Vn, this.Hi().cc());\n  }\n  Zp(t, i) {\n    const n = _(this.Mp).Ga();\n    for (const s of n) this.Qp(t, i, En, s);\n    for (const s of n) this.Qp(t, i, Vn, s);\n  }\n  Qp(t, i, n, s) {\n    const e = _(this.Mp),\n      r = i(s, e),\n      h = e.Ut().rc(),\n      l = null !== h && h.lc === s,\n      a = null !== h && l && void 0 !== h.Ip ? h.Ip.sr : void 0;\n    for (const i of r) {\n      const s = i.Mt();\n      null !== s && n(s, t, l, a);\n    }\n  }\n  $p(t, i, n) {\n    for (const s of t) {\n      const t = s.Mt();\n      if (null !== t && t.ir) {\n        const e = t.ir(i, n);\n        if (null !== e) return {\n          yf: s,\n          Ip: e\n        };\n      }\n    }\n    return null;\n  }\n  Dp() {\n    if (null === this.Mp) return;\n    const t = this.Sp,\n      i = this.Mp.Eo().F().visible,\n      n = this.Mp.Vo().F().visible;\n    i || null === this._p || (this.kp.removeChild(this._p.qf()), this._p.M(), this._p = null), n || null === this.up || (this.Cp.removeChild(this.up.qf()), this.up.M(), this.up = null);\n    const s = t.Ut().Pc();\n    i && null === this._p && (this._p = new In(this, t.F(), s, \"left\"), this.kp.appendChild(this._p.qf())), n && null === this.up && (this.up = new In(this, t.F(), s, \"right\"), this.Cp.appendChild(this.up.qf()));\n  }\n  tv(t) {\n    return t.Mf && this.vp || null !== this.mp;\n  }\n  iv(t) {\n    return Math.max(0, Math.min(t, this.Cf.width - 1));\n  }\n  nv(t) {\n    return Math.max(0, Math.min(t, this.Cf.height - 1));\n  }\n  Ap(t, i, n) {\n    this.Hi().kc(this.iv(t), this.nv(i), n, _(this.Mp));\n  }\n  Fp() {\n    this.Hi().Cc();\n  }\n  jp() {\n    this.bp && (this.mp = null, this.Fp());\n  }\n  Np(t, i, n) {\n    this.mp = t, this.bp = !1, this.Ap(i.x, i.y, n);\n    const s = this.Hi().cc();\n    this.gp = {\n      x: s.Xt(),\n      y: s.Zt()\n    };\n  }\n  Hi() {\n    return this.Sp.Ut();\n  }\n  zp(t) {\n    if (!this.dp) return;\n    const i = this.Hi(),\n      n = this.Qf();\n    if (i.$o(n, n.fn()), this.cp = null, this.dp = !1, i.Sc(), null !== this.wp) {\n      const t = performance.now(),\n        n = i.yt();\n      this.wp.pr(n.au(), t), this.wp.gu(t) || i.Yn(this.wp);\n    }\n  }\n  Op() {\n    this.mp = null;\n  }\n  Lp() {\n    if (!this.Mp) return;\n    if (this.Hi().Hn(), document.activeElement !== document.body && document.activeElement !== document.documentElement) _(document.activeElement).blur();else {\n      const t = document.getSelection();\n      null !== t && t.removeAllRanges();\n    }\n    !this.Mp.fn().Ni() && this.Hi().yt().Ni();\n  }\n  Vp(t) {\n    if (null === this.Mp) return;\n    const i = this.Hi(),\n      n = i.yt();\n    if (n.Ni()) return;\n    const s = this.Sp.F(),\n      e = s.handleScroll,\n      r = s.kineticScroll;\n    if ((!e.pressedMouseMove || t.Mf) && (!e.horzTouchDrag && !e.vertTouchDrag || !t.Mf)) return;\n    const h = this.Mp.fn(),\n      l = performance.now();\n    if (null !== this.cp || this.tv(t) || (this.cp = {\n      x: t.clientX,\n      y: t.clientY,\n      __: l,\n      sv: t.localX,\n      ev: t.localY\n    }), null !== this.cp && !this.dp && (this.cp.x !== t.clientX || this.cp.y !== t.clientY)) {\n      if (t.Mf && r.touch || !t.Mf && r.mouse) {\n        const t = n.Ks();\n        this.wp = new Cn(.2 / t, 7 / t, .997, 15 / t), this.wp.Yc(n.au(), this.cp.__);\n      } else this.wp = null;\n      h.Ni() || i.Wo(this.Mp, h, t.localY), i.wc(t.localX), this.dp = !0;\n    }\n    this.dp && (h.Ni() || i.jo(this.Mp, h, t.localY), i.Mc(t.localX), null !== this.wp && this.wp.Yc(n.au(), l));\n  }\n}\nclass jn {\n  constructor(i, n, s, e, r) {\n    this.vt = !0, this.Cf = t({\n      width: 0,\n      height: 0\n    }), this.Bf = () => this.tp(3), this.Lf = \"left\" === i, this.Ku = s.Pc, this.un = n, this.rv = e, this.hv = r, this.If = document.createElement(\"div\"), this.If.style.width = \"25px\", this.If.style.height = \"100%\", this.If.style.overflow = \"hidden\", this.Ef = Tn(this.If, t({\n      width: 16,\n      height: 16\n    })), this.Ef.subscribeSuggestedBitmapSizeChanged(this.Bf);\n  }\n  M() {\n    this.Ef.unsubscribeSuggestedBitmapSizeChanged(this.Bf), this.Ef.dispose();\n  }\n  qf() {\n    return this.If;\n  }\n  Up() {\n    return this.Cf;\n  }\n  Gf(t) {\n    n(this.Cf, t) || (this.Cf = t, this.Ef.resizeCanvasElement(t), this.If.style.width = \"\".concat(t.width, \"px\"), this.If.style.height = \"\".concat(t.height, \"px\"), this.vt = !0);\n  }\n  tp(t) {\n    if (t < 3 && !this.vt) return;\n    if (0 === this.Cf.width || 0 === this.Cf.height) return;\n    this.vt = !1, this.Ef.applySuggestedBitmapSize();\n    const i = s(this.Ef);\n    null !== i && i.useBitmapCoordinateSpace(t => {\n      this.np(t), this.ye(t);\n    });\n  }\n  hp() {\n    return this.Ef.bitmapSize;\n  }\n  lp(t, i, n) {\n    const s = this.hp();\n    s.width > 0 && s.height > 0 && t.drawImage(this.Ef.canvasElement, i, n);\n  }\n  ye(_ref18) {\n    let {\n      context: t,\n      bitmapSize: i,\n      horizontalPixelRatio: n,\n      verticalPixelRatio: s\n    } = _ref18;\n    if (!this.rv()) return;\n    t.fillStyle = this.un.timeScale.borderColor;\n    const e = Math.floor(this.Ku.F().k * n),\n      r = Math.floor(this.Ku.F().k * s),\n      h = this.Lf ? i.width - e : 0;\n    t.fillRect(h, 0, e, r);\n  }\n  np(_ref19) {\n    let {\n      context: t,\n      bitmapSize: i\n    } = _ref19;\n    $(t, 0, 0, i.width, i.height, this.hv());\n  }\n}\nfunction $n(t, i) {\n  return t.g_ > i.g_ ? t : i;\n}\nclass Hn {\n  constructor(i) {\n    this.lv = null, this.av = null, this.S = null, this.ov = !1, this.Cf = t({\n      width: 0,\n      height: 0\n    }), this._v = new M(), this.Pf = new Ht(5), this.Df = !1, this.Bf = () => {\n      this.Df || this.Sp.Ut().Ch();\n    }, this.Af = () => {\n      this.Df || this.Sp.Ut().Ch();\n    }, this.Sp = i, this.un = i.F().layout, this.uv = document.createElement(\"tr\"), this.cv = document.createElement(\"td\"), this.cv.style.padding = \"0\", this.dv = document.createElement(\"td\"), this.dv.style.padding = \"0\", this.If = document.createElement(\"td\"), this.If.style.height = \"25px\", this.If.style.padding = \"0\", this.fv = document.createElement(\"div\"), this.fv.style.width = \"100%\", this.fv.style.height = \"100%\", this.fv.style.position = \"relative\", this.fv.style.overflow = \"hidden\", this.If.appendChild(this.fv), this.Ef = Tn(this.fv, t({\n      width: 16,\n      height: 16\n    })), this.Ef.subscribeSuggestedBitmapSizeChanged(this.Bf);\n    const n = this.Ef.canvasElement;\n    n.style.position = \"absolute\", n.style.zIndex = \"1\", n.style.left = \"0\", n.style.top = \"0\", this.Vf = Tn(this.fv, t({\n      width: 16,\n      height: 16\n    })), this.Vf.subscribeSuggestedBitmapSizeChanged(this.Af);\n    const s = this.Vf.canvasElement;\n    s.style.position = \"absolute\", s.style.zIndex = \"2\", s.style.left = \"0\", s.style.top = \"0\", this.uv.appendChild(this.cv), this.uv.appendChild(this.If), this.uv.appendChild(this.dv), this.pv(), this.Sp.Ut().To().l(this.pv.bind(this), this), this.Uf = new Rn(this.Vf.canvasElement, this, {\n      Xd: () => !0,\n      Zd: () => !1\n    });\n  }\n  M() {\n    this.Uf.M(), null !== this.lv && this.lv.M(), null !== this.av && this.av.M(), this.Vf.unsubscribeSuggestedBitmapSizeChanged(this.Af), this.Vf.dispose(), this.Ef.unsubscribeSuggestedBitmapSizeChanged(this.Bf), this.Ef.dispose();\n  }\n  qf() {\n    return this.uv;\n  }\n  vv() {\n    return this.lv;\n  }\n  mv() {\n    return this.av;\n  }\n  af(t) {\n    if (this.ov) return;\n    this.ov = !0;\n    const i = this.Sp.Ut();\n    !i.yt().Ni() && this.Sp.F().handleScale.axisPressedMouseMove.time && i.mc(t.localX);\n  }\n  hf(t) {\n    this.af(t);\n  }\n  _f() {\n    const t = this.Sp.Ut();\n    !t.yt().Ni() && this.ov && (this.ov = !1, this.Sp.F().handleScale.axisPressedMouseMove.time && t.yc());\n  }\n  Jd(t) {\n    const i = this.Sp.Ut();\n    !i.yt().Ni() && this.Sp.F().handleScale.axisPressedMouseMove.time && i.xc(t.localX);\n  }\n  Kd(t) {\n    this.Jd(t);\n  }\n  nf() {\n    this.ov = !1;\n    const t = this.Sp.Ut();\n    t.yt().Ni() && !this.Sp.F().handleScale.axisPressedMouseMove.time || t.yc();\n  }\n  tf() {\n    this.nf();\n  }\n  Ed() {\n    this.Sp.F().handleScale.axisDoubleClickReset.time && this.Sp.Ut().Zn();\n  }\n  Od() {\n    this.Ed();\n  }\n  $d() {\n    this.Sp.Ut().F().handleScale.axisPressedMouseMove.time && this.ap(1);\n  }\n  gf() {\n    this.ap(0);\n  }\n  Up() {\n    return this.Cf;\n  }\n  bv() {\n    return this._v;\n  }\n  gv(i, s, e) {\n    n(this.Cf, i) || (this.Cf = i, this.Df = !0, this.Ef.resizeCanvasElement(i), this.Vf.resizeCanvasElement(i), this.Df = !1, this.If.style.width = \"\".concat(i.width, \"px\"), this.If.style.height = \"\".concat(i.height, \"px\"), this._v.m(i)), null !== this.lv && this.lv.Gf(t({\n      width: s,\n      height: i.height\n    })), null !== this.av && this.av.Gf(t({\n      width: e,\n      height: i.height\n    }));\n  }\n  wv() {\n    const t = this.Mv();\n    return Math.ceil(t.k + t.C + t.T + t.I + t.O + t.Sv);\n  }\n  gt() {\n    this.Sp.Ut().yt().Gl();\n  }\n  hp() {\n    return this.Ef.bitmapSize;\n  }\n  lp(t, i, n) {\n    const s = this.hp();\n    s.width > 0 && s.height > 0 && t.drawImage(this.Ef.canvasElement, i, n);\n  }\n  tp(t) {\n    if (0 === t) return;\n    if (1 !== t) {\n      this.Ef.applySuggestedBitmapSize();\n      const i = s(this.Ef);\n      null !== i && (i.useBitmapCoordinateSpace(t => {\n        this.np(t), this.ye(t);\n      }), this.sp(i)), null !== this.lv && this.lv.tp(t), null !== this.av && this.av.tp(t);\n    }\n    this.Vf.applySuggestedBitmapSize();\n    const i = s(this.Vf);\n    null !== i && (i.useBitmapCoordinateSpace(_ref20 => {\n      let {\n        context: t,\n        bitmapSize: i\n      } = _ref20;\n      t.clearRect(0, 0, i.width, i.height);\n    }), this.xv([this.Sp.Ut().cc()], i));\n  }\n  np(_ref21) {\n    let {\n      context: t,\n      bitmapSize: i\n    } = _ref21;\n    $(t, 0, 0, i.width, i.height, this.Sp.Ut().Lc());\n  }\n  ye(_ref22) {\n    let {\n      context: t,\n      bitmapSize: i,\n      verticalPixelRatio: n\n    } = _ref22;\n    if (this.Sp.F().timeScale.borderVisible) {\n      t.fillStyle = this.yv();\n      const s = Math.max(1, Math.floor(this.Mv().k * n));\n      t.fillRect(0, 0, i.width, s);\n    }\n  }\n  sp(t) {\n    const i = this.Sp.Ut().yt(),\n      n = i.Gl();\n    if (!n || 0 === n.length) return;\n    let s = n.reduce($n, n[0]).g_;\n    s > 30 && s < 50 && (s = 30);\n    const e = this.Mv(),\n      r = i.F();\n    r.borderVisible && r.ticksVisible && t.useBitmapCoordinateSpace(_ref23 => {\n      let {\n        context: t,\n        horizontalPixelRatio: i,\n        verticalPixelRatio: s\n      } = _ref23;\n      t.strokeStyle = this.yv(), t.fillStyle = this.yv();\n      const r = Math.max(1, Math.floor(i)),\n        h = Math.floor(.5 * i);\n      t.beginPath();\n      const l = Math.round(e.C * s);\n      for (let s = n.length; s--;) {\n        const e = Math.round(n[s].ql * i);\n        t.rect(e - h, 0, r, l);\n      }\n      t.fill();\n    }), t.useMediaCoordinateSpace(_ref24 => {\n      let {\n        context: t\n      } = _ref24;\n      const i = e.k + e.C + e.I + e.T / 2;\n      t.textAlign = \"center\", t.textBaseline = \"middle\", t.fillStyle = this.$(), t.font = this.Zf();\n      for (const e of n) if (e.g_ < s) {\n        const n = e.uu ? this.kv(t, e.ql, e._a) : e.ql;\n        t.fillText(e._a, n, i);\n      }\n      t.font = this.Cv();\n      for (const e of n) if (e.g_ >= s) {\n        const n = e.uu ? this.kv(t, e.ql, e._a) : e.ql;\n        t.fillText(e._a, n, i);\n      }\n    });\n  }\n  kv(t, i, n) {\n    const s = this.Pf.Si(t, n),\n      e = s / 2,\n      r = Math.floor(i - e) + .5;\n    return r < 0 ? i += Math.abs(0 - r) : r + s > this.Cf.width && (i -= Math.abs(this.Cf.width - (r + s))), i;\n  }\n  xv(t, i) {\n    const n = this.Mv();\n    for (const s of t) for (const t of s.Qi()) t.Mt().X(i, n);\n  }\n  yv() {\n    return this.Sp.F().timeScale.borderColor;\n  }\n  $() {\n    return this.un.textColor;\n  }\n  W() {\n    return this.un.fontSize;\n  }\n  Zf() {\n    return B(this.W(), this.un.fontFamily);\n  }\n  Cv() {\n    return B(this.W(), this.un.fontFamily, \"bold\");\n  }\n  Mv() {\n    null === this.S && (this.S = {\n      k: 1,\n      V: NaN,\n      I: NaN,\n      O: NaN,\n      ji: NaN,\n      C: 5,\n      T: NaN,\n      P: \"\",\n      Wi: new Ht(),\n      Sv: 0\n    });\n    const t = this.S,\n      i = this.Zf();\n    if (t.P !== i) {\n      const n = this.W();\n      t.T = n, t.P = i, t.I = 3 * n / 12, t.O = 3 * n / 12, t.ji = 9 * n / 12, t.V = 0, t.Sv = 4 * n / 12, t.Wi.Fe();\n    }\n    return this.S;\n  }\n  ap(t) {\n    this.If.style.cursor = 1 === t ? \"ew-resize\" : \"default\";\n  }\n  pv() {\n    const t = this.Sp.Ut(),\n      i = t.F();\n    i.leftPriceScale.visible || null === this.lv || (this.cv.removeChild(this.lv.qf()), this.lv.M(), this.lv = null), i.rightPriceScale.visible || null === this.av || (this.dv.removeChild(this.av.qf()), this.av.M(), this.av = null);\n    const n = {\n        Pc: this.Sp.Ut().Pc()\n      },\n      s = () => i.leftPriceScale.borderVisible && t.yt().F().borderVisible,\n      e = () => t.Lc();\n    i.leftPriceScale.visible && null === this.lv && (this.lv = new jn(\"left\", i, n, s, e), this.cv.appendChild(this.lv.qf())), i.rightPriceScale.visible && null === this.av && (this.av = new jn(\"right\", i, n, s, e), this.dv.appendChild(this.av.qf()));\n  }\n}\nconst Un = !!wn && !!navigator.userAgentData && navigator.userAgentData.brands.some(t => t.brand.includes(\"Chromium\")) && !!wn && ((null === (qn = null === navigator || void 0 === navigator ? void 0 : navigator.userAgentData) || void 0 === qn ? void 0 : qn.platform) ? \"Windows\" === navigator.userAgentData.platform : navigator.userAgent.toLowerCase().indexOf(\"win\") >= 0);\nvar qn;\nclass Yn {\n  constructor(t, i) {\n    var n;\n    this.Tv = [], this.Pv = 0, this.da = 0, this.po = 0, this.Rv = 0, this.Dv = 0, this.Bv = null, this.Ov = !1, this.fp = new M(), this.Yu = new M(), this.Av = null, this.Lv = t, this.un = i, this.uv = document.createElement(\"div\"), this.uv.classList.add(\"tv-lightweight-charts\"), this.uv.style.overflow = \"hidden\", this.uv.style.width = \"100%\", this.uv.style.height = \"100%\", (n = this.uv).style.userSelect = \"none\", n.style.webkitUserSelect = \"none\", n.style.msUserSelect = \"none\", n.style.MozUserSelect = \"none\", n.style.webkitTapHighlightColor = \"transparent\", this.Iv = document.createElement(\"table\"), this.Iv.setAttribute(\"cellspacing\", \"0\"), this.uv.appendChild(this.Iv), this.Ev = this.Vv.bind(this), Xn(this.un) && this.zv(!0), this.Hi = new mn(this.Zu.bind(this), this.un), this.Ut().dc().l(this.Nv.bind(this), this), this.Fv = new Hn(this), this.Iv.appendChild(this.Fv.qf());\n    const s = i.autoSize && this.Wv();\n    let e = this.un.width,\n      r = this.un.height;\n    if (s || 0 === e || 0 === r) {\n      const i = t.getBoundingClientRect();\n      e = e || i.width, r = r || i.height;\n    }\n    s || this.jv(e, r), this.$v(), t.appendChild(this.uv), this.Hv(), this.Hi.yt().xu().l(this.Hi.dl.bind(this.Hi), this), this.Hi.To().l(this.Hi.dl.bind(this.Hi), this);\n  }\n  Ut() {\n    return this.Hi;\n  }\n  F() {\n    return this.un;\n  }\n  Uv() {\n    return this.Tv;\n  }\n  qv() {\n    return this.Fv;\n  }\n  M() {\n    this.zv(!1), 0 !== this.Pv && window.cancelAnimationFrame(this.Pv), this.Hi.dc().v(this), this.Hi.yt().xu().v(this), this.Hi.To().v(this), this.Hi.M();\n    for (const t of this.Tv) this.Iv.removeChild(t.qf()), t.Wp().v(this), t.M();\n    this.Tv = [], _(this.Fv).M(), null !== this.uv.parentElement && this.uv.parentElement.removeChild(this.uv), this.Yu.M(), this.fp.M(), this.Yv();\n  }\n  jv(i, n) {\n    let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n    if (this.da === n && this.po === i) return;\n    const e = function (i) {\n      const n = Math.floor(i.width),\n        s = Math.floor(i.height);\n      return t({\n        width: n - n % 2,\n        height: s - s % 2\n      });\n    }(t({\n      width: i,\n      height: n\n    }));\n    this.da = e.height, this.po = e.width;\n    const r = this.da + \"px\",\n      h = this.po + \"px\";\n    _(this.uv).style.height = r, _(this.uv).style.width = h, this.Iv.style.height = r, this.Iv.style.width = h, s ? this.Xv(et.ss(), performance.now()) : this.Hi.dl();\n  }\n  tp(t) {\n    void 0 === t && (t = et.ss());\n    for (let i = 0; i < this.Tv.length; i++) this.Tv[i].tp(t.jn(i).Nn);\n    this.un.timeScale.visible && this.Fv.tp(t.Wn());\n  }\n  kh(t) {\n    const i = Xn(this.un);\n    this.Hi.kh(t);\n    const n = Xn(this.un);\n    n !== i && this.zv(n), this.Hv(), this.Zv(t);\n  }\n  Wp() {\n    return this.fp;\n  }\n  dc() {\n    return this.Yu;\n  }\n  Kv() {\n    null !== this.Bv && (this.Xv(this.Bv, performance.now()), this.Bv = null);\n    const t = this.Gv(null),\n      i = document.createElement(\"canvas\");\n    i.width = t.width, i.height = t.height;\n    const n = _(i.getContext(\"2d\"));\n    return this.Gv(n), i;\n  }\n  Jv(t) {\n    if (\"left\" === t && !this.Qv()) return 0;\n    if (\"right\" === t && !this.tm()) return 0;\n    if (0 === this.Tv.length) return 0;\n    return _(\"left\" === t ? this.Tv[0].Gp() : this.Tv[0].Jp()).Jf();\n  }\n  Zv(t) {\n    (void 0 !== t.autoSize || !this.Av || void 0 === t.width && void 0 === t.height) && (t.autoSize && !this.Av && this.Wv(), !1 === t.autoSize && null !== this.Av && this.Yv(), t.autoSize || void 0 === t.width && void 0 === t.height || this.jv(t.width || this.po, t.height || this.da));\n  }\n  Gv(i) {\n    let n = 0,\n      s = 0;\n    const e = this.Tv[0],\n      r = (t, n) => {\n        let s = 0;\n        for (let e = 0; e < this.Tv.length; e++) {\n          const r = this.Tv[e],\n            h = _(\"left\" === t ? r.Gp() : r.Jp()),\n            l = h.hp();\n          null !== i && h.lp(i, n, s), s += l.height;\n        }\n      };\n    if (this.Qv()) {\n      r(\"left\", 0);\n      n += _(e.Gp()).hp().width;\n    }\n    for (let t = 0; t < this.Tv.length; t++) {\n      const e = this.Tv[t],\n        r = e.hp();\n      null !== i && e.lp(i, n, s), s += r.height;\n    }\n    if (n += e.hp().width, this.tm()) {\n      r(\"right\", n);\n      n += _(e.Jp()).hp().width;\n    }\n    const h = (t, n, s) => {\n      _(\"left\" === t ? this.Fv.vv() : this.Fv.mv()).lp(_(i), n, s);\n    };\n    if (this.un.timeScale.visible) {\n      const t = this.Fv.hp();\n      if (null !== i) {\n        let n = 0;\n        this.Qv() && (h(\"left\", n, s), n = _(e.Gp()).hp().width), this.Fv.lp(i, n, s), n += t.width, this.tm() && h(\"right\", n, s);\n      }\n      s += t.height;\n    }\n    return t({\n      width: n,\n      height: s\n    });\n  }\n  im() {\n    let i = 0,\n      n = 0,\n      s = 0;\n    for (const t of this.Tv) this.Qv() && (n = Math.max(n, _(t.Gp()).Xf())), this.tm() && (s = Math.max(s, _(t.Jp()).Xf())), i += t.Po();\n    n = xn(n), s = xn(s);\n    const e = this.po,\n      r = this.da,\n      h = Math.max(e - n - s, 0),\n      l = this.un.timeScale.visible;\n    let a = l ? this.Fv.wv() : 0;\n    var o;\n    a = (o = a) + o % 2;\n    const u = 0 + a,\n      c = r < u ? 0 : r - u,\n      d = c / i;\n    let f = 0;\n    for (let i = 0; i < this.Tv.length; ++i) {\n      const e = this.Tv[i];\n      e.Rp(this.Hi._c()[i]);\n      let r = 0,\n        l = 0;\n      l = i === this.Tv.length - 1 ? c - f : Math.round(e.Po() * d), r = Math.max(l, 2), f += r, e.Gf(t({\n        width: h,\n        height: r\n      })), this.Qv() && e.Hp(n, \"left\"), this.tm() && e.Hp(s, \"right\"), e.Qf() && this.Hi.fc(e.Qf(), r);\n    }\n    this.Fv.gv(t({\n      width: l ? h : 0,\n      height: a\n    }), l ? n : 0, l ? s : 0), this.Hi.Do(h), this.Rv !== n && (this.Rv = n), this.Dv !== s && (this.Dv = s);\n  }\n  zv(t) {\n    t ? this.uv.addEventListener(\"wheel\", this.Ev, {\n      passive: !1\n    }) : this.uv.removeEventListener(\"wheel\", this.Ev);\n  }\n  nm(t) {\n    switch (t.deltaMode) {\n      case t.DOM_DELTA_PAGE:\n        return 120;\n      case t.DOM_DELTA_LINE:\n        return 32;\n    }\n    return Un ? 1 / window.devicePixelRatio : 1;\n  }\n  Vv(t) {\n    if (!(0 !== t.deltaX && this.un.handleScroll.mouseWheel || 0 !== t.deltaY && this.un.handleScale.mouseWheel)) return;\n    const i = this.nm(t),\n      n = i * t.deltaX / 100,\n      s = -i * t.deltaY / 100;\n    if (t.cancelable && t.preventDefault(), 0 !== s && this.un.handleScale.mouseWheel) {\n      const i = Math.sign(s) * Math.min(1, Math.abs(s)),\n        n = t.clientX - this.uv.getBoundingClientRect().left;\n      this.Ut().bc(n, i);\n    }\n    0 !== n && this.un.handleScroll.mouseWheel && this.Ut().gc(-80 * n);\n  }\n  Xv(t, i) {\n    var n;\n    const s = t.Wn();\n    3 === s && this.sm(), 3 !== s && 2 !== s || (this.rm(t), this.hm(t, i), this.Fv.gt(), this.Tv.forEach(t => {\n      t.Bp();\n    }), 3 === (null === (n = this.Bv) || void 0 === n ? void 0 : n.Wn()) && (this.Bv.Qn(t), this.sm(), this.rm(this.Bv), this.hm(this.Bv, i), t = this.Bv, this.Bv = null)), this.tp(t);\n  }\n  hm(t, i) {\n    for (const n of t.Jn()) this.ts(n, i);\n  }\n  rm(t) {\n    const i = this.Hi._c();\n    for (let n = 0; n < i.length; n++) t.jn(n).Fn && i[n].qo();\n  }\n  ts(t, i) {\n    const n = this.Hi.yt();\n    switch (t.Un) {\n      case 0:\n        n.ku();\n        break;\n      case 1:\n        n.Cu(t.Ot);\n        break;\n      case 2:\n        n.Kn(t.Ot);\n        break;\n      case 3:\n        n.Gn(t.Ot);\n        break;\n      case 4:\n        n.cu();\n        break;\n      case 5:\n        t.Ot.gu(i) || n.Gn(t.Ot.wu(i));\n    }\n  }\n  Zu(t) {\n    null !== this.Bv ? this.Bv.Qn(t) : this.Bv = t, this.Ov || (this.Ov = !0, this.Pv = window.requestAnimationFrame(t => {\n      if (this.Ov = !1, this.Pv = 0, null !== this.Bv) {\n        const i = this.Bv;\n        this.Bv = null, this.Xv(i, t);\n        for (const n of i.Jn()) if (5 === n.Un && !n.Ot.gu(t)) {\n          this.Ut().Yn(n.Ot);\n          break;\n        }\n      }\n    }));\n  }\n  sm() {\n    this.$v();\n  }\n  $v() {\n    const t = this.Hi._c(),\n      i = t.length,\n      n = this.Tv.length;\n    for (let t = i; t < n; t++) {\n      const t = o(this.Tv.pop());\n      this.Iv.removeChild(t.qf()), t.Wp().v(this), t.M();\n    }\n    for (let s = n; s < i; s++) {\n      const i = new Wn(this, t[s]);\n      i.Wp().l(this.lm.bind(this), this), this.Tv.push(i), this.Iv.insertBefore(i.qf(), this.Fv.qf());\n    }\n    for (let n = 0; n < i; n++) {\n      const i = t[n],\n        s = this.Tv[n];\n      s.Qf() !== i ? s.Rp(i) : s.Pp();\n    }\n    this.Hv(), this.im();\n  }\n  am(t, i, n) {\n    var s;\n    const e = new Map();\n    if (null !== t) {\n      this.Hi.wt().forEach(i => {\n        const n = i.Ln().jh(t);\n        null !== n && e.set(i, n);\n      });\n    }\n    let r;\n    if (null !== t) {\n      const i = null === (s = this.Hi.yt().Ui(t)) || void 0 === s ? void 0 : s.w_;\n      void 0 !== i && (r = i);\n    }\n    const h = this.Ut().rc(),\n      l = null !== h && h.lc instanceof Ti ? h.lc : void 0,\n      a = null !== h && void 0 !== h.Ip ? h.Ip.nr : void 0;\n    return {\n      _t: r,\n      Ys: null != t ? t : void 0,\n      om: null != i ? i : void 0,\n      _m: l,\n      um: e,\n      dm: a,\n      fm: null != n ? n : void 0\n    };\n  }\n  lm(t, i, n) {\n    this.fp.m(() => this.am(t, i, n));\n  }\n  Nv(t, i, n) {\n    this.Yu.m(() => this.am(t, i, n));\n  }\n  Hv() {\n    const t = this.un.timeScale.visible ? \"\" : \"none\";\n    this.Fv.qf().style.display = t;\n  }\n  Qv() {\n    return this.Tv[0].Qf().Eo().F().visible;\n  }\n  tm() {\n    return this.Tv[0].Qf().Vo().F().visible;\n  }\n  Wv() {\n    return \"ResizeObserver\" in window && (this.Av = new ResizeObserver(t => {\n      const i = t.find(t => t.target === this.Lv);\n      i && this.jv(i.contentRect.width, i.contentRect.height);\n    }), this.Av.observe(this.Lv, {\n      box: \"border-box\"\n    }), !0);\n  }\n  Yv() {\n    null !== this.Av && this.Av.disconnect();\n  }\n}\nfunction Xn(t) {\n  return Boolean(t.handleScroll.mouseWheel || t.handleScale.mouseWheel);\n}\nfunction Zn(t, i, n, s) {\n  const e = n.value,\n    r = {\n      Ys: i,\n      _t: t,\n      Ot: [e, e, e, e],\n      w_: s\n    };\n  return void 0 !== n.color && (r.D = n.color), r;\n}\nfunction Kn(t) {\n  return void 0 !== t.Ot;\n}\nfunction Gn(t) {\n  return (i, n, s, e) => {\n    return void 0 === (r = s).open && void 0 === r.value ? {\n      _t: i,\n      Ys: n,\n      w_: e\n    } : t(i, n, s, e);\n    var r;\n  };\n}\nconst Jn = {\n  Candlestick: Gn(function (t, i, n, s) {\n    const e = {\n      Ys: i,\n      _t: t,\n      Ot: [n.open, n.high, n.low, n.close],\n      w_: s\n    };\n    return void 0 !== n.color && (e.D = n.color), void 0 !== n.borderColor && (e.At = n.borderColor), void 0 !== n.wickColor && (e.Dh = n.wickColor), e;\n  }),\n  Bar: Gn(function (t, i, n, s) {\n    const e = {\n      Ys: i,\n      _t: t,\n      Ot: [n.open, n.high, n.low, n.close],\n      w_: s\n    };\n    return void 0 !== n.color && (e.D = n.color), e;\n  }),\n  Area: Gn(function (t, i, n, s) {\n    const e = n.value,\n      r = {\n        Ys: i,\n        _t: t,\n        Ot: [e, e, e, e],\n        w_: s\n      };\n    return void 0 !== n.lineColor && (r.ot = n.lineColor), void 0 !== n.topColor && (r.bs = n.topColor), void 0 !== n.bottomColor && (r.gs = n.bottomColor), r;\n  }),\n  Baseline: Gn(function (t, i, n, s) {\n    const e = n.value,\n      r = {\n        Ys: i,\n        _t: t,\n        Ot: [e, e, e, e],\n        w_: s\n      };\n    return void 0 !== n.topLineColor && (r.be = n.topLineColor), void 0 !== n.bottomLineColor && (r.ge = n.bottomLineColor), void 0 !== n.topFillColor1 && (r.de = n.topFillColor1), void 0 !== n.topFillColor2 && (r.fe = n.topFillColor2), void 0 !== n.bottomFillColor1 && (r.pe = n.bottomFillColor1), void 0 !== n.bottomFillColor2 && (r.ve = n.bottomFillColor2), r;\n  }),\n  Histogram: Gn(Zn),\n  Line: Gn(Zn)\n};\nfunction Qn(t) {\n  return Jn[t];\n}\nfunction ts(t) {\n  return 60 * t * 60 * 1e3;\n}\nfunction is(t) {\n  return 60 * t * 1e3;\n}\nconst ns = [{\n  pm: (ss = 1, 1e3 * ss),\n  g_: 10\n}, {\n  pm: is(1),\n  g_: 20\n}, {\n  pm: is(5),\n  g_: 21\n}, {\n  pm: is(30),\n  g_: 22\n}, {\n  pm: ts(1),\n  g_: 30\n}, {\n  pm: ts(3),\n  g_: 31\n}, {\n  pm: ts(6),\n  g_: 32\n}, {\n  pm: ts(12),\n  g_: 33\n}];\nvar ss;\nfunction es(t, i) {\n  if (t.getUTCFullYear() !== i.getUTCFullYear()) return 70;\n  if (t.getUTCMonth() !== i.getUTCMonth()) return 60;\n  if (t.getUTCDate() !== i.getUTCDate()) return 50;\n  for (let n = ns.length - 1; n >= 0; --n) if (Math.floor(i.getTime() / ns[n].pm) !== Math.floor(t.getTime() / ns[n].pm)) return ns[n].g_;\n  return 0;\n}\nfunction rs(t) {\n  let i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (0 === t.length) return;\n  let n = 0 === i ? null : t[i - 1]._t.__,\n    s = null !== n ? new Date(1e3 * n) : null,\n    e = 0;\n  for (let r = i; r < t.length; ++r) {\n    const i = t[r],\n      h = new Date(1e3 * i._t.__);\n    null !== s && (i.b_ = es(h, s)), e += i._t.__ - (n || i._t.__), n = i._t.__, s = h;\n  }\n  if (0 === i && t.length > 1) {\n    const i = Math.ceil(e / (t.length - 1)),\n      n = new Date(1e3 * (t[0]._t.__ - i));\n    t[0].b_ = es(new Date(1e3 * t[0]._t.__), n);\n  }\n}\nfunction hs(t) {\n  if (!bn(t)) throw new Error(\"time must be of type BusinessDay\");\n  const i = new Date(Date.UTC(t.year, t.month - 1, t.day, 0, 0, 0, 0));\n  return {\n    __: Math.round(i.getTime() / 1e3),\n    o_: t\n  };\n}\nfunction ls(t) {\n  if (!gn(t)) throw new Error(\"time must be of type isUTCTimestamp\");\n  return {\n    __: t\n  };\n}\nfunction as(t) {\n  return 0 === t.length ? null : bn(t[0].time) ? hs : ls;\n}\nfunction os(t) {\n  return gn(t) ? ls(t) : bn(t) ? hs(t) : hs(_s(t));\n}\nfunction _s(t) {\n  const i = new Date(t);\n  if (isNaN(i.getTime())) throw new Error(\"Invalid date string=\".concat(t, \", expected format=yyyy-mm-dd\"));\n  return {\n    day: i.getUTCDate(),\n    month: i.getUTCMonth() + 1,\n    year: i.getUTCFullYear()\n  };\n}\nfunction us(t) {\n  k(t.time) && (t.time = _s(t.time));\n}\nfunction cs(t) {\n  return {\n    Ys: 0,\n    vm: new Map(),\n    yl: t\n  };\n}\nfunction ds(t) {\n  if (void 0 !== t && 0 !== t.length) return {\n    bm: t[0]._t.__,\n    gm: t[t.length - 1]._t.__\n  };\n}\nfunction fs(t) {\n  let i;\n  return t.forEach(t => {\n    void 0 === i && (i = t.w_);\n  }), o(i);\n}\nfunction ps(t) {\n  void 0 === t.w_ && (t.w_ = t.time);\n}\nclass vs {\n  constructor() {\n    this.wm = new Map(), this.Mm = new Map(), this.Sm = new Map(), this.xm = [];\n  }\n  M() {\n    this.wm.clear(), this.Mm.clear(), this.Sm.clear(), this.xm = [];\n  }\n  ym(t, i) {\n    let n = 0 !== this.wm.size,\n      s = !1;\n    const e = this.Mm.get(t);\n    if (void 0 !== e) if (1 === this.Mm.size) n = !1, s = !0, this.wm.clear();else for (const i of this.xm) i.pointData.vm.delete(t) && (s = !0);\n    let r = [];\n    if (0 !== i.length) {\n      const n = i;\n      n.forEach(t => ps(t)), function (t) {\n        t.forEach(us);\n      }(i);\n      const e = _(as(i)),\n        h = Qn(t.Lh());\n      r = n.map(i => {\n        const n = e(i.time);\n        let r = this.wm.get(n.__);\n        void 0 === r && (r = cs(n), this.wm.set(n.__, r), s = !0);\n        const l = h(n, r.Ys, i, i.w_);\n        return r.vm.set(t, l), l;\n      });\n    }\n    n && this.km(), this.Cm(t, r);\n    let h = -1;\n    if (s) {\n      const t = [];\n      this.wm.forEach(i => {\n        t.push({\n          b_: 0,\n          _t: i.yl,\n          pointData: i,\n          w_: fs(i.vm)\n        });\n      }), t.sort((t, i) => t._t.__ - i._t.__), h = this.Tm(t);\n    }\n    return this.Pm(t, h, function (t, i) {\n      const n = ds(t),\n        s = ds(i);\n      if (void 0 !== n && void 0 !== s) return {\n        ml: n.gm >= s.gm && n.bm >= s.bm\n      };\n    }(this.Mm.get(t), e));\n  }\n  Bc(t) {\n    return this.ym(t, []);\n  }\n  Rm(t, i) {\n    const n = i;\n    ps(n), us(i);\n    const s = _(as([i]))(i.time),\n      e = this.Sm.get(t);\n    if (void 0 !== e && s.__ < e.__) throw new Error(\"Cannot update oldest data, last time=\".concat(e.__, \", new time=\").concat(s.__));\n    let r = this.wm.get(s.__);\n    const h = void 0 === r;\n    void 0 === r && (r = cs(s), this.wm.set(s.__, r));\n    const l = Qn(t.Lh())(s, r.Ys, i, n.w_);\n    r.vm.set(t, l), this.Dm(t, l);\n    const a = {\n      ml: Kn(l)\n    };\n    if (!h) return this.Pm(t, -1, a);\n    const o = {\n        b_: 0,\n        _t: r.yl,\n        pointData: r,\n        w_: fs(r.vm)\n      },\n      u = wt(this.xm, o._t.__, (t, i) => t._t.__ < i);\n    this.xm.splice(u, 0, o);\n    for (let t = u; t < this.xm.length; ++t) ms(this.xm[t].pointData, t);\n    return rs(this.xm, u), this.Pm(t, u, a);\n  }\n  Dm(t, i) {\n    let n = this.Mm.get(t);\n    void 0 === n && (n = [], this.Mm.set(t, n));\n    const s = 0 !== n.length ? n[n.length - 1] : null;\n    null === s || i._t.__ > s._t.__ ? Kn(i) && n.push(i) : Kn(i) ? n[n.length - 1] = i : n.splice(-1, 1), this.Sm.set(t, i._t);\n  }\n  Cm(t, i) {\n    0 !== i.length ? (this.Mm.set(t, i.filter(Kn)), this.Sm.set(t, i[i.length - 1]._t)) : (this.Mm.delete(t), this.Sm.delete(t));\n  }\n  km() {\n    for (const t of this.xm) 0 === t.pointData.vm.size && this.wm.delete(t._t.__);\n  }\n  Tm(t) {\n    let i = -1;\n    for (let n = 0; n < this.xm.length && n < t.length; ++n) {\n      const s = this.xm[n],\n        e = t[n];\n      if (s._t.__ !== e._t.__) {\n        i = n;\n        break;\n      }\n      e.b_ = s.b_, ms(e.pointData, n);\n    }\n    if (-1 === i && this.xm.length !== t.length && (i = Math.min(this.xm.length, t.length)), -1 === i) return -1;\n    for (let n = i; n < t.length; ++n) ms(t[n].pointData, n);\n    return rs(t, i), this.xm = t, i;\n  }\n  Bm() {\n    if (0 === this.Mm.size) return null;\n    let t = 0;\n    return this.Mm.forEach(i => {\n      0 !== i.length && (t = Math.max(t, i[i.length - 1].Ys));\n    }), t;\n  }\n  Pm(t, i, n) {\n    const s = {\n      Om: new Map(),\n      yt: {\n        su: this.Bm()\n      }\n    };\n    if (-1 !== i) this.Mm.forEach((i, e) => {\n      s.Om.set(e, {\n        ar: i,\n        Am: e === t ? n : void 0\n      });\n    }), this.Mm.has(t) || s.Om.set(t, {\n      ar: [],\n      Am: n\n    }), s.yt.Lm = this.xm, s.yt.Im = i;else {\n      const i = this.Mm.get(t);\n      s.Om.set(t, {\n        ar: i || [],\n        Am: n\n      });\n    }\n    return s;\n  }\n}\nfunction ms(t, i) {\n  t.Ys = i, t.vm.forEach(t => {\n    t.Ys = i;\n  });\n}\nfunction bs(t) {\n  return {\n    value: t.Ot[3],\n    time: t.w_\n  };\n}\nfunction gs(t) {\n  const i = bs(t);\n  return void 0 !== t.D && (i.color = t.D), i;\n}\nfunction ws(t) {\n  return {\n    open: t.Ot[0],\n    high: t.Ot[1],\n    low: t.Ot[2],\n    close: t.Ot[3],\n    time: t.w_\n  };\n}\nconst Ms = {\n  Area: function (t) {\n    const i = bs(t);\n    return void 0 !== t.ot && (i.lineColor = t.ot), void 0 !== t.bs && (i.topColor = t.bs), void 0 !== t.gs && (i.bottomColor = t.gs), i;\n  },\n  Line: gs,\n  Baseline: function (t) {\n    const i = bs(t);\n    return void 0 !== t.be && (i.topLineColor = t.be), void 0 !== t.ge && (i.bottomLineColor = t.ge), void 0 !== t.de && (i.topFillColor1 = t.de), void 0 !== t.fe && (i.topFillColor2 = t.fe), void 0 !== t.pe && (i.bottomFillColor1 = t.pe), void 0 !== t.ve && (i.bottomFillColor2 = t.ve), i;\n  },\n  Histogram: gs,\n  Bar: function (t) {\n    const i = ws(t);\n    return void 0 !== t.D && (i.color = t.D), i;\n  },\n  Candlestick: function (t) {\n    const i = ws(t),\n      {\n        D: n,\n        At: s,\n        Dh: e\n      } = t;\n    return void 0 !== n && (i.color = n), void 0 !== s && (i.borderColor = s), void 0 !== e && (i.wickColor = e), i;\n  }\n};\nfunction Ss(t) {\n  return Ms[t];\n}\nconst xs = {\n    autoScale: !0,\n    mode: 0,\n    invertScale: !1,\n    alignLabels: !0,\n    borderVisible: !0,\n    borderColor: \"#2B2B43\",\n    entireTextOnly: !1,\n    visible: !1,\n    ticksVisible: !1,\n    scaleMargins: {\n      bottom: .1,\n      top: .2\n    }\n  },\n  ys = {\n    color: \"rgba(0, 0, 0, 0)\",\n    visible: !1,\n    fontSize: 48,\n    fontFamily: D,\n    fontStyle: \"\",\n    text: \"\",\n    horzAlign: \"center\",\n    vertAlign: \"center\"\n  },\n  ks = {\n    width: 0,\n    height: 0,\n    autoSize: !1,\n    layout: {\n      background: {\n        type: \"solid\",\n        color: \"#FFFFFF\"\n      },\n      textColor: \"#191919\",\n      fontSize: 12,\n      fontFamily: D\n    },\n    crosshair: {\n      vertLine: {\n        color: \"#9598A1\",\n        width: 1,\n        style: 3,\n        visible: !0,\n        labelVisible: !0,\n        labelBackgroundColor: \"#131722\"\n      },\n      horzLine: {\n        color: \"#9598A1\",\n        width: 1,\n        style: 3,\n        visible: !0,\n        labelVisible: !0,\n        labelBackgroundColor: \"#131722\"\n      },\n      mode: 1\n    },\n    grid: {\n      vertLines: {\n        color: \"#D6DCDE\",\n        style: 0,\n        visible: !0\n      },\n      horzLines: {\n        color: \"#D6DCDE\",\n        style: 0,\n        visible: !0\n      }\n    },\n    overlayPriceScales: Object.assign({}, xs),\n    leftPriceScale: Object.assign(Object.assign({}, xs), {\n      visible: !1\n    }),\n    rightPriceScale: Object.assign(Object.assign({}, xs), {\n      visible: !0\n    }),\n    timeScale: {\n      rightOffset: 0,\n      barSpacing: 6,\n      minBarSpacing: .5,\n      fixLeftEdge: !1,\n      fixRightEdge: !1,\n      lockVisibleTimeRangeOnResize: !1,\n      rightBarStaysOnScroll: !1,\n      borderVisible: !0,\n      borderColor: \"#2B2B43\",\n      visible: !0,\n      timeVisible: !1,\n      secondsVisible: !0,\n      shiftVisibleRangeOnNewBar: !0,\n      ticksVisible: !1\n    },\n    watermark: ys,\n    localization: {\n      locale: wn ? navigator.language : \"\",\n      dateFormat: \"dd MMM 'yy\"\n    },\n    handleScroll: {\n      mouseWheel: !0,\n      pressedMouseMove: !0,\n      horzTouchDrag: !0,\n      vertTouchDrag: !0\n    },\n    handleScale: {\n      axisPressedMouseMove: {\n        time: !0,\n        price: !0\n      },\n      axisDoubleClickReset: {\n        time: !0,\n        price: !0\n      },\n      mouseWheel: !0,\n      pinch: !0\n    },\n    kineticScroll: {\n      mouse: !1,\n      touch: !0\n    },\n    trackingMode: {\n      exitMode: 1\n    }\n  },\n  Cs = {\n    upColor: \"#26a69a\",\n    downColor: \"#ef5350\",\n    wickVisible: !0,\n    borderVisible: !0,\n    borderColor: \"#378658\",\n    borderUpColor: \"#26a69a\",\n    borderDownColor: \"#ef5350\",\n    wickColor: \"#737375\",\n    wickUpColor: \"#26a69a\",\n    wickDownColor: \"#ef5350\"\n  },\n  Ts = {\n    upColor: \"#26a69a\",\n    downColor: \"#ef5350\",\n    openVisible: !0,\n    thinBars: !0\n  },\n  Ps = {\n    color: \"#2196f3\",\n    lineStyle: 0,\n    lineWidth: 3,\n    lineType: 0,\n    crosshairMarkerVisible: !0,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: \"\",\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: \"\",\n    lastPriceAnimation: 0\n  },\n  Rs = {\n    topColor: \"rgba( 46, 220, 135, 0.4)\",\n    bottomColor: \"rgba( 40, 221, 100, 0)\",\n    invertFilledArea: !1,\n    lineColor: \"#33D778\",\n    lineStyle: 0,\n    lineWidth: 3,\n    lineType: 0,\n    crosshairMarkerVisible: !0,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: \"\",\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: \"\",\n    lastPriceAnimation: 0\n  },\n  Ds = {\n    baseValue: {\n      type: \"price\",\n      price: 0\n    },\n    topFillColor1: \"rgba(38, 166, 154, 0.28)\",\n    topFillColor2: \"rgba(38, 166, 154, 0.05)\",\n    topLineColor: \"rgba(38, 166, 154, 1)\",\n    bottomFillColor1: \"rgba(239, 83, 80, 0.05)\",\n    bottomFillColor2: \"rgba(239, 83, 80, 0.28)\",\n    bottomLineColor: \"rgba(239, 83, 80, 1)\",\n    lineWidth: 3,\n    lineStyle: 0,\n    lineType: 0,\n    crosshairMarkerVisible: !0,\n    crosshairMarkerRadius: 4,\n    crosshairMarkerBorderColor: \"\",\n    crosshairMarkerBorderWidth: 2,\n    crosshairMarkerBackgroundColor: \"\",\n    lastPriceAnimation: 0\n  },\n  Bs = {\n    color: \"#26a69a\",\n    base: 0\n  },\n  Os = {\n    title: \"\",\n    visible: !0,\n    lastValueVisible: !0,\n    priceLineVisible: !0,\n    priceLineSource: 0,\n    priceLineWidth: 1,\n    priceLineColor: \"\",\n    priceLineStyle: 2,\n    baseLineVisible: !0,\n    baseLineWidth: 1,\n    baseLineColor: \"#B2B5BE\",\n    baseLineStyle: 0,\n    priceFormat: {\n      type: \"price\",\n      precision: 2,\n      minMove: .01\n    }\n  };\nclass As {\n  constructor(t, i) {\n    this.Em = t, this.Vm = i;\n  }\n  applyOptions(t) {\n    this.Em.Ut().ac(this.Vm, t);\n  }\n  options() {\n    return this.Vi().F();\n  }\n  width() {\n    return st(this.Vm) ? this.Em.Jv(this.Vm) : 0;\n  }\n  Vi() {\n    return _(this.Em.Ut().oc(this.Vm)).Bt;\n  }\n}\nconst Ls = {\n  color: \"#FF0000\",\n  price: 0,\n  lineStyle: 2,\n  lineWidth: 1,\n  lineVisible: !0,\n  axisLabelVisible: !0,\n  title: \"\"\n};\nclass Is {\n  constructor(t) {\n    this.wh = t;\n  }\n  applyOptions(t) {\n    this.wh.kh(t);\n  }\n  options() {\n    return this.wh.F();\n  }\n  zm() {\n    return this.wh;\n  }\n}\nclass Es {\n  constructor(t, i, n) {\n    this.Ts = t, this.Nm = i, this.Fm = n;\n  }\n  priceFormatter() {\n    return this.Ts.Bl();\n  }\n  priceToCoordinate(t) {\n    const i = this.Ts.Tt();\n    return null === i ? null : this.Ts.Bt().Dt(t, i.Ot);\n  }\n  coordinateToPrice(t) {\n    const i = this.Ts.Tt();\n    return null === i ? null : this.Ts.Bt().pn(t, i.Ot);\n  }\n  barsInLogicalRange(t) {\n    if (null === t) return null;\n    const i = new ln(new en(t.from, t.to)).k_(),\n      n = this.Ts.Ln();\n    if (n.Ni()) return null;\n    const s = n.jh(i.Ms(), 1),\n      e = n.jh(i.ci(), -1),\n      r = _(n.Nh()),\n      h = _(n.An());\n    if (null !== s && null !== e && s.Ys > e.Ys) return {\n      barsBefore: t.from - r,\n      barsAfter: h - t.to\n    };\n    const l = {\n      barsBefore: null === s || s.Ys === r ? t.from - r : s.Ys - r,\n      barsAfter: null === e || e.Ys === h ? h - t.to : h - e.Ys\n    };\n    return null !== s && null !== e && (l.from = s._t.o_ || s._t.__, l.to = e._t.o_ || e._t.__), l;\n  }\n  setData(t) {\n    this.Ts.Lh(), this.Nm.Wm(this.Ts, t);\n  }\n  update(t) {\n    this.Ts.Lh(), this.Nm.jm(this.Ts, t);\n  }\n  dataByIndex(t, i) {\n    const n = this.Ts.Ln().jh(t, i);\n    return null === n ? null : Ss(this.seriesType())(n);\n  }\n  setMarkers(t) {\n    const i = t.map(t => Object.assign(Object.assign({}, t), {\n      originalTime: t.time,\n      time: os(t.time)\n    }));\n    this.Ts.gl(i);\n  }\n  markers() {\n    return this.Ts.wl().map(t => {\n      const {\n          originalTime: i,\n          time: n\n        } = t,\n        s = function (t, i) {\n          var n = {};\n          for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && i.indexOf(s) < 0 && (n[s] = t[s]);\n          if (null != t && \"function\" == typeof Object.getOwnPropertySymbols) {\n            var e = 0;\n            for (s = Object.getOwnPropertySymbols(t); e < s.length; e++) i.indexOf(s[e]) < 0 && Object.prototype.propertyIsEnumerable.call(t, s[e]) && (n[s[e]] = t[s[e]]);\n          }\n          return n;\n        }(t, [\"originalTime\", \"time\"]);\n      return Object.assign({\n        time: i\n      }, s);\n    });\n  }\n  applyOptions(t) {\n    this.Ts.kh(t);\n  }\n  options() {\n    return T(this.Ts.F());\n  }\n  priceScale() {\n    return this.Fm.priceScale(this.Ts.Bt().Vl());\n  }\n  createPriceLine(t) {\n    const i = S(T(Ls), t),\n      n = this.Ts.Ml(i);\n    return new Is(n);\n  }\n  removePriceLine(t) {\n    this.Ts.Sl(t.zm());\n  }\n  seriesType() {\n    return this.Ts.Lh();\n  }\n}\nclass Vs {\n  constructor(t, i) {\n    this.$m = new M(), this.I_ = new M(), this._v = new M(), this.Hi = t, this.bo = t.yt(), this.Fv = i, this.bo.Mu().l(this.Hm.bind(this)), this.bo.Su().l(this.Um.bind(this)), this.Fv.bv().l(this.qm.bind(this));\n  }\n  M() {\n    this.bo.Mu().v(this), this.bo.Su().v(this), this.Fv.bv().v(this), this.$m.M(), this.I_.M(), this._v.M();\n  }\n  scrollPosition() {\n    return this.bo.au();\n  }\n  scrollToPosition(t, i) {\n    i ? this.bo.bu(t, 1e3) : this.Hi.Gn(t);\n  }\n  scrollToRealTime() {\n    this.bo.mu();\n  }\n  getVisibleRange() {\n    var t, i;\n    const n = this.bo.K_();\n    return null === n ? null : {\n      from: null !== (t = n.from.o_) && void 0 !== t ? t : n.from.__,\n      to: null !== (i = n.to.o_) && void 0 !== i ? i : n.to.__\n    };\n  }\n  setVisibleRange(t) {\n    const i = {\n        from: os(t.from),\n        to: os(t.to)\n      },\n      n = this.bo.tu(i);\n    this.Hi.Oc(n);\n  }\n  getVisibleLogicalRange() {\n    const t = this.bo.Z_();\n    return null === t ? null : {\n      from: t.Ms(),\n      to: t.ci()\n    };\n  }\n  setVisibleLogicalRange(t) {\n    a(t.from <= t.to, \"The from index cannot be after the to index.\"), this.Hi.Oc(t);\n  }\n  resetTimeScale() {\n    this.Hi.Zn();\n  }\n  fitContent() {\n    this.Hi.ku();\n  }\n  logicalToCoordinate(t) {\n    const i = this.Hi.yt();\n    return i.Ni() ? null : i.Et(t);\n  }\n  coordinateToLogical(t) {\n    return this.bo.Ni() ? null : this.bo.eu(t);\n  }\n  timeToCoordinate(t) {\n    const i = os(t),\n      n = this.bo.Nl(i, !1);\n    return null === n ? null : this.bo.Et(n);\n  }\n  coordinateToTime(t) {\n    var i;\n    const n = this.Hi.yt(),\n      s = n.eu(t),\n      e = n.vn(s);\n    return null === e ? null : null !== (i = e.o_) && void 0 !== i ? i : e.__;\n  }\n  width() {\n    return this.Fv.Up().width;\n  }\n  height() {\n    return this.Fv.Up().height;\n  }\n  subscribeVisibleTimeRangeChange(t) {\n    this.$m.l(t);\n  }\n  unsubscribeVisibleTimeRangeChange(t) {\n    this.$m.p(t);\n  }\n  subscribeVisibleLogicalRangeChange(t) {\n    this.I_.l(t);\n  }\n  unsubscribeVisibleLogicalRangeChange(t) {\n    this.I_.p(t);\n  }\n  subscribeSizeChange(t) {\n    this._v.l(t);\n  }\n  unsubscribeSizeChange(t) {\n    this._v.p(t);\n  }\n  applyOptions(t) {\n    this.bo.kh(t);\n  }\n  options() {\n    return T(this.bo.F());\n  }\n  Hm() {\n    this.$m.g() && this.$m.m(this.getVisibleRange());\n  }\n  Um() {\n    this.I_.g() && this.I_.m(this.getVisibleLogicalRange());\n  }\n  qm(t) {\n    this._v.m(t.width, t.height);\n  }\n}\nfunction zs(t) {\n  if (void 0 === t || \"custom\" === t.type) return;\n  const i = t;\n  void 0 !== i.minMove && void 0 === i.precision && (i.precision = function (t) {\n    if (t >= 1) return 0;\n    let i = 0;\n    for (; i < 8; i++) {\n      const n = Math.round(t);\n      if (Math.abs(n - t) < 1e-8) return i;\n      t *= 10;\n    }\n    return i;\n  }(i.minMove));\n}\nfunction Ns(t) {\n  return function (t) {\n    if (C(t.handleScale)) {\n      const i = t.handleScale;\n      t.handleScale = {\n        axisDoubleClickReset: {\n          time: i,\n          price: i\n        },\n        axisPressedMouseMove: {\n          time: i,\n          price: i\n        },\n        mouseWheel: i,\n        pinch: i\n      };\n    } else if (void 0 !== t.handleScale) {\n      const {\n        axisPressedMouseMove: i,\n        axisDoubleClickReset: n\n      } = t.handleScale;\n      C(i) && (t.handleScale.axisPressedMouseMove = {\n        time: i,\n        price: i\n      }), C(n) && (t.handleScale.axisDoubleClickReset = {\n        time: n,\n        price: n\n      });\n    }\n    const i = t.handleScroll;\n    C(i) && (t.handleScroll = {\n      horzTouchDrag: i,\n      vertTouchDrag: i,\n      mouseWheel: i,\n      pressedMouseMove: i\n    });\n  }(t), t;\n}\nclass Fs {\n  constructor(t, i) {\n    this.Ym = new vs(), this.Xm = new Map(), this.Zm = new Map(), this.Km = new M(), this.Gm = new M();\n    const n = void 0 === i ? T(ks) : S(T(ks), Ns(i));\n    this.Em = new Yn(t, n), this.Em.Wp().l(t => {\n      this.Km.g() && this.Km.m(this.Jm(t()));\n    }, this), this.Em.dc().l(t => {\n      this.Gm.g() && this.Gm.m(this.Jm(t()));\n    }, this);\n    const s = this.Em.Ut();\n    this.Qm = new Vs(s, this.Em.qv());\n  }\n  remove() {\n    this.Em.Wp().v(this), this.Em.dc().v(this), this.Qm.M(), this.Em.M(), this.Xm.clear(), this.Zm.clear(), this.Km.M(), this.Gm.M(), this.Ym.M();\n  }\n  resize(t, i, n) {\n    this.Em.jv(t, i, n);\n  }\n  addAreaSeries(t) {\n    return this.tb(\"Area\", Rs, t);\n  }\n  addBaselineSeries(t) {\n    return this.tb(\"Baseline\", Ds, t);\n  }\n  addBarSeries(t) {\n    return this.tb(\"Bar\", Ts, t);\n  }\n  addCandlestickSeries() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return function (t) {\n      void 0 !== t.borderColor && (t.borderUpColor = t.borderColor, t.borderDownColor = t.borderColor), void 0 !== t.wickColor && (t.wickUpColor = t.wickColor, t.wickDownColor = t.wickColor);\n    }(t), this.tb(\"Candlestick\", Cs, t);\n  }\n  addHistogramSeries(t) {\n    return this.tb(\"Histogram\", Bs, t);\n  }\n  addLineSeries(t) {\n    return this.tb(\"Line\", Ps, t);\n  }\n  removeSeries(t) {\n    const i = o(this.Xm.get(t)),\n      n = this.Ym.Bc(i);\n    this.Em.Ut().Bc(i), this.ib(n), this.Xm.delete(t), this.Zm.delete(i);\n  }\n  Wm(t, i) {\n    this.ib(this.Ym.ym(t, i));\n  }\n  jm(t, i) {\n    this.ib(this.Ym.Rm(t, i));\n  }\n  subscribeClick(t) {\n    this.Km.l(t);\n  }\n  unsubscribeClick(t) {\n    this.Km.p(t);\n  }\n  subscribeCrosshairMove(t) {\n    this.Gm.l(t);\n  }\n  unsubscribeCrosshairMove(t) {\n    this.Gm.p(t);\n  }\n  priceScale(t) {\n    return new As(this.Em, t);\n  }\n  timeScale() {\n    return this.Qm;\n  }\n  applyOptions(t) {\n    this.Em.kh(Ns(t));\n  }\n  options() {\n    return this.Em.F();\n  }\n  takeScreenshot() {\n    return this.Em.Kv();\n  }\n  tb(t, i) {\n    let n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    zs(n.priceFormat);\n    const s = S(T(Os), T(i), n),\n      e = this.Em.Ut().Rc(t, s),\n      r = new Es(e, this, this);\n    return this.Xm.set(r, e), this.Zm.set(e, r), r;\n  }\n  ib(t) {\n    const i = this.Em.Ut();\n    i.Tc(t.yt.su, t.yt.Lm, t.yt.Im), t.Om.forEach((t, i) => i.tt(t.ar, t.Am)), i.hu();\n  }\n  nb(t) {\n    return o(this.Zm.get(t));\n  }\n  Jm(t) {\n    const i = new Map();\n    t.um.forEach((t, n) => {\n      const s = Ss(n.Lh())(t);\n      a(function (t) {\n        return void 0 !== t.open || void 0 !== t.value;\n      }(s)), i.set(this.nb(n), s);\n    });\n    const n = void 0 === t._m ? void 0 : this.nb(t._m);\n    return {\n      time: t._t,\n      logical: t.Ys,\n      point: t.om,\n      hoveredSeries: n,\n      hoveredObjectId: t.dm,\n      seriesData: i,\n      sourceEvent: t.fm\n    };\n  }\n}\nfunction Ws(t, i) {\n  let n;\n  if (k(t)) {\n    const i = document.getElementById(t);\n    a(null !== i, \"Cannot find element in DOM with id=\".concat(t)), n = i;\n  } else n = t;\n  return new Fs(n, i);\n}\nfunction js() {\n  return \"4.0.0\";\n}\nexport { cn as ColorType, it as CrosshairMode, _n as LastPriceAnimationMode, r as LineStyle, e as LineType, xi as MismatchDirection, un as PriceLineSource, Ui as PriceScaleMode, an as TickMarkType, on as TrackingModeExitMode, Ws as createChart, bn as isBusinessDay, gn as isUTCTimestamp, js as version };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}